"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/analyze";
exports.ids = ["pages/api/analyze"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = import("axios");;

/***/ }),

/***/ "cheerio":
/*!**************************!*\
  !*** external "cheerio" ***!
  \**************************/
/***/ ((module) => {

module.exports = import("cheerio");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze.ts&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze.ts&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/analyze.ts */ \"(api)/./pages/api/analyze.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/analyze\",\n        pathname: \"/api/analyze\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_analyze_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmFuYWx5emUmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyUyRmFwaSUyRmFuYWx5emUudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDbUQ7QUFDbkQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGtEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxrREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZG0tYnVpbGRlci8/YzRkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL2FuYWx5emUudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9hbmFseXplXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYW5hbHl6ZVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/parser.ts":
/*!***********************!*\
  !*** ./lib/parser.ts ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseProduct: () => (/* binding */ parseProduct)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheerio */ \"cheerio\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([axios__WEBPACK_IMPORTED_MODULE_0__, cheerio__WEBPACK_IMPORTED_MODULE_1__]);\n([axios__WEBPACK_IMPORTED_MODULE_0__, cheerio__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * Shape of the information we care about from a product page.\n *\n * These fields mirror the placeholders used in templates. Some\n * fields are optional because not every page will expose them.\n */ // ProductData type moved to lib/types.ts\n/**\n * Attempt to parse structured JSON-LD data from the page. Many\n * eâ€‘commerce platforms embed an object with the schema.org\n * Product type. This helper extracts it if present.\n */ function parseLdJson($) {\n    const scripts = $('script[type=\"application/ld+json\"]').toArray();\n    for (const el of scripts){\n        const contents = $(el).contents().text();\n        if (!contents) continue;\n        try {\n            const json = JSON.parse(contents.trim());\n            // Sometimes multiple objects are wrapped in an array.\n            const candidates = Array.isArray(json) ? json : [\n                json\n            ];\n            for (const obj of candidates){\n                if (obj[\"@type\"] === \"Product\") {\n                    return obj;\n                }\n            }\n        } catch (_) {\n        // ignore JSON parse errors and continue.\n        }\n    }\n    return null;\n}\n/**\n * Generic helper to extract a meta tag value. It first tries to\n * match the given property on the `meta[property]` attribute (as used\n * by Open Graph), then falls back to `meta[name]`.\n */ function getMeta($, prop) {\n    return $(`meta[property='${prop}']`).attr(\"content\") || $(`meta[name='${prop}']`).attr(\"content\") || null;\n}\n/**\n * Fetch a product page and extract basic fields using heuristics. This\n * function does not attempt to deeply crawl the DOM; instead it relies\n * on Open Graph tags, JSONâ€‘LD and common microdata attributes. If a\n * field cannot be resolved it will be returned as an empty string.\n *\n * If the request fails for whatever reason the resulting object will\n * contain empty strings for all properties except url and cta.\n *\n * @param url Product page URL\n */ // Rotating modern user agents for retry strategy\nconst USER_AGENTS = [\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36\",\n    \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36\"\n];\nasync function fetchWithRetries(url, max = 3) {\n    let lastErr;\n    for(let attempt = 1; attempt <= max; attempt++){\n        const ua = USER_AGENTS[(attempt - 1) % USER_AGENTS.length];\n        try {\n            const res = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(url, {\n                headers: {\n                    \"User-Agent\": ua,\n                    \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n                    \"Accept-Language\": \"en-US,en;q=0.9\",\n                    \"Cache-Control\": \"no-cache\",\n                    \"Pragma\": \"no-cache\",\n                    \"Referer\": new URL(url).origin + \"/\"\n                },\n                maxRedirects: 5,\n                timeout: 12000,\n                validateStatus: (s)=>s < 500 || s === 503 || s === 429\n            });\n            if (res.status === 200) return {\n                html: res.data,\n                status: res.status\n            };\n            if ([\n                429,\n                403,\n                503\n            ].includes(res.status) && attempt < max) {\n                await new Promise((r)=>setTimeout(r, 350 * Math.pow(2, attempt - 1)));\n                continue;\n            }\n            return {\n                html: res.data,\n                status: res.status\n            };\n        } catch (e) {\n            lastErr = e;\n            if (attempt === max) throw e;\n            await new Promise((r)=>setTimeout(r, 350 * Math.pow(2, attempt - 1)));\n        }\n    }\n    throw lastErr;\n}\nasync function parseProduct(url) {\n    const clean = (value)=>(value || \"\").toString().trim();\n    // Normalise image URLs (protocol-relative, root-relative, and relative paths)\n    const buildNormaliser = (pageUrl)=>{\n        let origin = \"\";\n        let basePath = \"\";\n        try {\n            const u = new URL(pageUrl);\n            origin = u.origin;\n            basePath = pageUrl.endsWith(\"/\") ? pageUrl : pageUrl.substring(0, pageUrl.lastIndexOf(\"/\") + 1);\n        } catch (_) {}\n        return (raw)=>{\n            const val = (raw || \"\").trim();\n            if (!val) return \"\";\n            if (/^https?:\\/\\//i.test(val)) return val;\n            if (val.startsWith(\"//\")) return `https:${val}`; // assume https for protocol-relative\n            if (val.startsWith(\"/\")) return origin ? origin + val : val; // root-relative\n            return basePath ? basePath + val : val; // relative path\n        };\n    };\n    const normalise = buildNormaliser(url);\n    let html = \"\";\n    let status = 0;\n    try {\n        const fetched = await fetchWithRetries(url, 3);\n        html = fetched.html;\n        status = fetched.status;\n    } catch (error) {\n        console.error(`Failed to fetch ${url}:`, error instanceof Error ? error.message : error);\n        return {\n            url,\n            pretitle: \"\",\n            title: \"\",\n            price: \"\",\n            description: \"\",\n            image: \"\",\n            images: undefined,\n            cta: url,\n            ctaLabel: \"SHOP NOW\",\n            __fetchStatus: status || 0,\n            __reason: \"fetch-failed\"\n        };\n    }\n    const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n    // Remove any mega-menu content to avoid polluting extraction\n    try {\n        const reMega = /mega[-_ ]?menu/i;\n        const toRemove = $(\"[class]\").filter((_, el)=>reMega.test($(el).attr(\"class\") || \"\")).toArray();\n        if (toRemove.length) $(toRemove).remove();\n    } catch (_) {}\n    // Attempt to parse JSONâ€‘LD structured data first because it typically\n    // provides the richest information. We fall back to meta tags if\n    // structured data is not present or incomplete.\n    const ld = parseLdJson($) || {};\n    const product = {\n        url,\n        pretitle: \"\",\n        title: \"\",\n        price: \"\",\n        originalPrice: undefined,\n        description: \"\",\n        metadataDescription: undefined,\n        image: \"\",\n        images: undefined,\n        cta: url,\n        // Default call-to-action label. Users can override this in the\n        // preview by editing the CTA text. If not provided, templates\n        // will fall back to this value.\n        ctaLabel: \"SHOP NOW\"\n    };\n    product.__fetchStatus = status;\n    // Title\n    product.title = clean(ld.name) || clean(getMeta($, \"og:title\")) || clean(getMeta($, \"twitter:title\")) || clean($(\"title\").first().text());\n    // Description & metadata description\n    // We distinguish the page's canonical META description (<meta name=\"description\">)\n    // from other potential sources like JSON-LD Product.description or Open Graph / Twitter\n    // descriptions. Per requirement: metadataDescription must originate from the meta tag only.\n    const metaTagDescription = clean(getMeta($, \"description\"));\n    const ldDesc = clean(ld.description);\n    const ogDesc = clean(getMeta($, \"og:description\"));\n    const twitterDesc = clean(getMeta($, \"twitter:description\"));\n    // Assign only the literal <meta name=\"description\"> content to metadataDescription\n    product.metadataDescription = metaTagDescription || undefined;\n    if (metaTagDescription) {\n        product.originalMetadataDescription = metaTagDescription;\n    }\n    // Default user-facing description prefers the meta tag, then structured data, then OG/Twitter.\n    product.description = metaTagDescription || ldDesc || ogDesc || twitterDesc || \"\";\n    // Extract specific description sources from .product__description\n    try {\n        const descRoot = $(\".product__description\").first();\n        if (descRoot && descRoot.length) {\n            const p = descRoot.find(\"p\").first();\n            if (p && p.length) {\n                product.descriptionP = clean(p.text());\n            }\n            const ul = descRoot.find(\"ul\").first();\n            if (ul && ul.length) {\n                // Preserve UL structure as HTML for email preview/template\n                product.descriptionUl = $.html(ul);\n            }\n        }\n    } catch (e) {\n    // ignore extraction errors\n    }\n    // Image\n    const ldImage = Array.isArray(ld.image) ? ld.image[0] : typeof ld.image === \"string\" ? ld.image : undefined;\n    // Collect possible image candidates including lazy attrs & srcset\n    const firstImg = $(\"img\").first();\n    const srcset = firstImg.attr(\"srcset\");\n    let srcsetPick = \"\";\n    if (srcset) {\n        try {\n            // choose largest descriptor\n            const parts = srcset.split(\",\").map((p)=>p.trim());\n            let bestW = -1;\n            for (const part of parts){\n                const m = part.match(/\\s+(\\d+)[wx]$/);\n                const urlPart = part.replace(/\\s+(\\d+)[wx]$/, \"\").trim();\n                const w = m ? parseInt(m[1], 10) : 0;\n                if (w > bestW) {\n                    bestW = w;\n                    srcsetPick = urlPart;\n                }\n            }\n        } catch  {}\n    }\n    product.image = normalise(clean(ldImage) || clean(getMeta($, \"og:image:secure_url\")) || clean(getMeta($, \"og:image\")) || clean(getMeta($, \"twitter:image\")) || clean(firstImg.attr(\"data-src\")) || clean(firstImg.attr(\"data-lazy\")) || clean(srcsetPick) || clean(firstImg.attr(\"src\")));\n    // Price\n    const ldOffers = ld.offers;\n    let ldPrice;\n    if (ldOffers) {\n        if (Array.isArray(ldOffers)) {\n            ldPrice = ldOffers[0]?.price;\n        } else if (typeof ldOffers === \"object\") {\n            ldPrice = ldOffers.price;\n        }\n    }\n    product.price = clean(ldPrice) || clean(getMeta($, \"product:price:amount\")) || clean(getMeta($, \"og:price:amount\")) || // Try to match microdata on sites like Shopify: [itemprop=\"price\"]\n    clean($('[itemprop=\"price\"]').first().text());\n    // Original price: attempt to find a compareâ€‘at or strikeâ€‘through price. This\n    // can appear in JSONâ€‘LD as an \"priceSpecification\" with\n    // \"priceCurrency\" and \"value\", or in the DOM as <del> or a span with\n    // class containing \"compare\" or \"strike\". We attempt several heuristics\n    // and take the first numeric value we find. The value returned does\n    // not include the currency symbol.\n    let original;\n    // Check JSONâ€‘LD offers.comparePrice if present\n    if (ldOffers) {\n        // Some schemas nest compareAtPrice or originalPrice\n        const getCompare = (obj)=>{\n            if (!obj) return undefined;\n            return obj.compareAtPrice || obj.originalPrice || obj.priceSpecification?.price;\n        };\n        if (Array.isArray(ldOffers)) {\n            for (const off of ldOffers){\n                const val = getCompare(off);\n                if (val) {\n                    original = clean(val);\n                    break;\n                }\n            }\n        } else if (typeof ldOffers === \"object\") {\n            const val = getCompare(ldOffers);\n            if (val) {\n                original = clean(val);\n            }\n        }\n    }\n    if (!original) {\n        // Look for elements containing a price with a lineâ€‘through style or a\n        // class indicating \"compare\" or \"original\". We extract numeric\n        // values (digits and decimal separators).\n        const priceRegex = /([\\d,.]+)\\s*(?:[A-Z]{3})?/;\n        // helper to parse text\n        const parsePriceText = (text)=>{\n            const match = priceRegex.exec(text);\n            return match ? match[1] : undefined;\n        };\n        // Check <del> elements\n        $(\"del, strike\").each((_, el)=>{\n            const text = $(el).text();\n            const val = parsePriceText(text);\n            if (val) {\n                original = clean(val);\n                return false; // break the loop\n            }\n        });\n        // Check elements with class containing compare or original\n        if (!original) {\n            $('[class*=\"compare\"],[class*=\"original\"],[class*=\"strike\"]').each((_, el)=>{\n                const text = $(el).text();\n                const val = parsePriceText(text);\n                if (val) {\n                    original = clean(val);\n                    return false;\n                }\n            });\n        }\n    }\n    // Assign originalPrice if found and different from sale price\n    if (original && original !== product.price) {\n        product.originalPrice = original;\n    }\n    // Pretitle: not widely available. As a heuristic, if the title\n    // contains a hyphen, split the first part as pretitle and the rest\n    // as the actual title.\n    if (product.title && product.title.includes(\" â€“ \")) {\n        const parts = product.title.split(/\\s+â€“\\s+/);\n        if (parts.length > 1) {\n            product.pretitle = parts[0];\n            product.title = parts.slice(1).join(\" â€“ \");\n        }\n    }\n    // Colour capture removed per refactor; no swatch detection\n    // Images: collect additional image URLs beyond the primary image. We\n    // start with the primary image if it exists. Then search for image\n    // elements that are likely part of the product gallery. Heuristics\n    // include class names containing \"product\", \"gallery\", \"thumb\", or\n    // \"image\". We also accept JSONâ€‘LD image arrays. Only absolute\n    // URLs (http or https) are kept and duplicates removed.\n    const imageSet = new Set();\n    if (product.image) {\n        imageSet.add(product.image);\n    }\n    // Add any additional images from JSONâ€‘LD\n    if (Array.isArray(ld.image)) {\n        for (const img of ld.image){\n            if (typeof img === \"string\") {\n                imageSet.add(normalise(img));\n            }\n        }\n    }\n    // DOM extraction: find images with relevant class hints\n    $(\"img\").each((_, el)=>{\n        const src = normalise($(el).attr(\"src\"));\n        if (!src) return;\n        if (!/\\.(jpe?g|png|gif|webp|avif|svg)(?:[?#].*)?$/i.test(src)) return;\n        // Accept images if they contain certain keywords in their class or id\n        const classes = ($(el).attr(\"class\") || \"\") + \" \" + ($(el).parent().attr(\"class\") || \"\");\n        const ids = ($(el).attr(\"id\") || \"\") + \" \" + ($(el).parent().attr(\"id\") || \"\");\n        const hay = classes + \" \" + ids;\n        if (/product|gallery|thumb|image|slider|carousel/i.test(hay)) {\n            imageSet.add(src);\n        }\n    });\n    // Additional extraction: attempt to fetch the Shopify .js endpoint for\n    // richer product data. Many Shopify stores expose a JSON file at\n    // <product-url>.js which contains an array of image URLs and the\n    // featured image. If the request fails or the response is not JSON,\n    // we silently ignore it. We prefix protocol-relative URLs with\n    // https: to ensure absolute paths. Any images found here are added\n    // to imageSet. This logic mirrors the working implementation from\n    // the provided reference package. It avoids slicing the JSON by\n    // braces and instead lets JSON.parse handle the string.\n    try {\n        const jsUrl = url.endsWith(\".js\") ? url : `${url}.js`;\n        const jsResp = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(jsUrl, {\n            headers: {\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0 Safari/537.36\"\n            },\n            maxRedirects: 3\n        });\n        const jsData = jsResp.data;\n        // If response is a string, attempt to parse JSON; if it's already\n        // an object we can process it directly. Some platforms escape\n        // unicode sequences, but JSON.parse will handle them.\n        const parsedData = typeof jsData === \"string\" ? JSON.parse(jsData) : typeof jsData === \"object\" ? jsData : null;\n        if (parsedData && typeof parsedData === \"object\") {\n            // Extract images array\n            const imgs = parsedData.images;\n            if (Array.isArray(imgs)) {\n                for (const p of imgs){\n                    if (typeof p === \"string\" && p) {\n                        const imgUrl = normalise(p.startsWith(\"//\") ? `https:${p}` : p);\n                        if (imgUrl) {\n                            imageSet.add(imgUrl);\n                        }\n                    }\n                }\n            }\n            // Extract featured image\n            const feat = parsedData.featured_image;\n            if (typeof feat === \"string\" && feat) {\n                const full = normalise(feat.startsWith(\"//\") ? `https:${feat}` : feat);\n                if (full) {\n                    imageSet.add(full);\n                }\n            }\n        }\n    } catch (err) {\n    // Silently ignore errors; the JSON endpoint may not exist or may not\n    // return valid JSON. In such cases we simply rely on images\n    // extracted from the HTML and JSON-LD.\n    }\n    // Assign images array if more than one image is found\n    const imagesArr = Array.from(imageSet);\n    if (imagesArr.length > 0) {\n        // Assign the images directly from imageSet. The imageSet itself\n        // already deduplicates exact URLs while preserving insertion order.\n        // We no longer deduplicate by base path (query parameters) because\n        // some stores use the same base for different images. Instead we\n        // preserve all unique URLs. We still move the primary image to\n        // the front of the array if it exists and is not already first.\n        let deduped = imagesArr;\n        if (product.image) {\n            const index = deduped.findIndex((i)=>i === product.image);\n            if (index > 0) {\n                const [img] = deduped.splice(index, 1);\n                deduped.unshift(img);\n            } else if (index === -1) {\n                deduped.unshift(product.image);\n            }\n        }\n        product.images = deduped;\n    }\n    // If we failed structured extraction, attempt embedded script datasets (Next.js / Nuxt / etc.)\n    try {\n        if (!product.title) {\n            const nextMatch = html.match(/__NEXT_DATA__\\s*=\\s*(\\{[\\s\\S]*?\\})\\s*<\\/script>/);\n            if (nextMatch) {\n                try {\n                    const obj = JSON.parse(nextMatch[1]);\n                    const str = JSON.stringify(obj);\n                    // naive find of product title keys\n                    const titleMatch = str.match(/\"title\"\\s*:\\s*\"([^\"]{5,})\"/);\n                    if (titleMatch) product.title = clean(titleMatch[1]);\n                } catch  {}\n            }\n        }\n    } catch  {}\n    // Mark reason if nothing meaningful\n    const meaningfulKeys = [\n        \"title\",\n        \"description\",\n        \"image\",\n        \"price\",\n        \"originalPrice\",\n        \"images\",\n        \"pretitle\"\n    ];\n    const hasInfo = meaningfulKeys.some((k)=>{\n        const v = product[k];\n        return Array.isArray(v) ? v.length > 0 : Boolean(v && String(v).trim());\n    });\n    if (!hasInfo) {\n        product.__reason = product.__reason || (product.__fetchStatus && [\n            403,\n            429\n        ].includes(product.__fetchStatus) ? \"blocked\" : \"empty\");\n    }\n    return product;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFRO1FBQVE7UUFBZ0I7UUFBUztLQUFXO0lBQ2xHLE1BQU1DLFVBQVVELGVBQWVFLElBQUksQ0FBQ0MsQ0FBQUE7UUFDbEMsTUFBTUMsSUFBUyxPQUFnQixDQUFDRCxFQUFFO1FBQ2xDLE9BQU92SixNQUFNQyxPQUFPLENBQUN1SixLQUFLQSxFQUFFMUksTUFBTSxHQUFHLElBQUkySSxRQUFRRCxLQUFLRSxPQUFPRixHQUFHMUosSUFBSTtJQUN0RTtJQUNBLElBQUksQ0FBQ3VKLFNBQVM7UUFDWjdFLFFBQVFQLFFBQVEsR0FBR08sUUFBUVAsUUFBUSxJQUFLTyxDQUFBQSxRQUFRUixhQUFhLElBQUk7WUFBQztZQUFJO1NBQUksQ0FBQ3JDLFFBQVEsQ0FBQzZDLFFBQVFSLGFBQWEsSUFBSSxZQUFZLE9BQU07SUFDakk7SUFDQSxPQUFPUTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRtLWJ1aWxkZXIvLi9saWIvcGFyc2VyLnRzPzRhNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCAqIGFzIGNoZWVyaW8gZnJvbSAnY2hlZXJpbyc7XG5pbXBvcnQgeyBQcm9kdWN0RGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFNoYXBlIG9mIHRoZSBpbmZvcm1hdGlvbiB3ZSBjYXJlIGFib3V0IGZyb20gYSBwcm9kdWN0IHBhZ2UuXG4gKlxuICogVGhlc2UgZmllbGRzIG1pcnJvciB0aGUgcGxhY2Vob2xkZXJzIHVzZWQgaW4gdGVtcGxhdGVzLiBTb21lXG4gKiBmaWVsZHMgYXJlIG9wdGlvbmFsIGJlY2F1c2Ugbm90IGV2ZXJ5IHBhZ2Ugd2lsbCBleHBvc2UgdGhlbS5cbiAqL1xuLy8gUHJvZHVjdERhdGEgdHlwZSBtb3ZlZCB0byBsaWIvdHlwZXMudHNcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHBhcnNlIHN0cnVjdHVyZWQgSlNPTi1MRCBkYXRhIGZyb20gdGhlIHBhZ2UuIE1hbnlcbiAqIGXigJFjb21tZXJjZSBwbGF0Zm9ybXMgZW1iZWQgYW4gb2JqZWN0IHdpdGggdGhlIHNjaGVtYS5vcmdcbiAqIFByb2R1Y3QgdHlwZS4gVGhpcyBoZWxwZXIgZXh0cmFjdHMgaXQgaWYgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VMZEpzb24oJDogY2hlZXJpby5DaGVlcmlvQVBJKTogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGwge1xuICBjb25zdCBzY3JpcHRzID0gJCgnc2NyaXB0W3R5cGU9XCJhcHBsaWNhdGlvbi9sZCtqc29uXCJdJykudG9BcnJheSgpO1xuICBmb3IgKGNvbnN0IGVsIG9mIHNjcmlwdHMpIHtcbiAgICBjb25zdCBjb250ZW50cyA9ICQoZWwpLmNvbnRlbnRzKCkudGV4dCgpO1xuICAgIGlmICghY29udGVudHMpIGNvbnRpbnVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShjb250ZW50cy50cmltKCkpO1xuICAgICAgLy8gU29tZXRpbWVzIG11bHRpcGxlIG9iamVjdHMgYXJlIHdyYXBwZWQgaW4gYW4gYXJyYXkuXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gQXJyYXkuaXNBcnJheShqc29uKSA/IGpzb24gOiBbanNvbl07XG4gICAgICBmb3IgKGNvbnN0IG9iaiBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICAgIGlmIChvYmpbJ0B0eXBlJ10gPT09ICdQcm9kdWN0Jykge1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAvLyBpZ25vcmUgSlNPTiBwYXJzZSBlcnJvcnMgYW5kIGNvbnRpbnVlLlxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHZW5lcmljIGhlbHBlciB0byBleHRyYWN0IGEgbWV0YSB0YWcgdmFsdWUuIEl0IGZpcnN0IHRyaWVzIHRvXG4gKiBtYXRjaCB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGBtZXRhW3Byb3BlcnR5XWAgYXR0cmlidXRlIChhcyB1c2VkXG4gKiBieSBPcGVuIEdyYXBoKSwgdGhlbiBmYWxscyBiYWNrIHRvIGBtZXRhW25hbWVdYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWV0YSgkOiBjaGVlcmlvLkNoZWVyaW9BUEksIHByb3A6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICByZXR1cm4gKFxuICAgICQoYG1ldGFbcHJvcGVydHk9JyR7cHJvcH0nXWApLmF0dHIoJ2NvbnRlbnQnKSB8fFxuICAgICQoYG1ldGFbbmFtZT0nJHtwcm9wfSddYCkuYXR0cignY29udGVudCcpIHx8XG4gICAgbnVsbFxuICApO1xufVxuXG4vKipcbiAqIEZldGNoIGEgcHJvZHVjdCBwYWdlIGFuZCBleHRyYWN0IGJhc2ljIGZpZWxkcyB1c2luZyBoZXVyaXN0aWNzLiBUaGlzXG4gKiBmdW5jdGlvbiBkb2VzIG5vdCBhdHRlbXB0IHRvIGRlZXBseSBjcmF3bCB0aGUgRE9NOyBpbnN0ZWFkIGl0IHJlbGllc1xuICogb24gT3BlbiBHcmFwaCB0YWdzLCBKU09O4oCRTEQgYW5kIGNvbW1vbiBtaWNyb2RhdGEgYXR0cmlidXRlcy4gSWYgYVxuICogZmllbGQgY2Fubm90IGJlIHJlc29sdmVkIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gZW1wdHkgc3RyaW5nLlxuICpcbiAqIElmIHRoZSByZXF1ZXN0IGZhaWxzIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbFxuICogY29udGFpbiBlbXB0eSBzdHJpbmdzIGZvciBhbGwgcHJvcGVydGllcyBleGNlcHQgdXJsIGFuZCBjdGEuXG4gKlxuICogQHBhcmFtIHVybCBQcm9kdWN0IHBhZ2UgVVJMXG4gKi9cbi8vIFJvdGF0aW5nIG1vZGVybiB1c2VyIGFnZW50cyBmb3IgcmV0cnkgc3RyYXRlZ3lcbmNvbnN0IFVTRVJfQUdFTlRTID0gW1xuICAnTW96aWxsYS81LjAgKE1hY2ludG9zaDsgSW50ZWwgTWFjIE9TIFggMTRfMykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyNC4wIFNhZmFyaS81MzcuMzYnLFxuICAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyNC4wIFNhZmFyaS81MzcuMzYnLFxuICAnTW96aWxsYS81LjAgKFgxMTsgTGludXggeDg2XzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTI0LjAgU2FmYXJpLzUzNy4zNidcbl07XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aFJldHJpZXModXJsOiBzdHJpbmcsIG1heCA9IDMpOiBQcm9taXNlPHsgaHRtbDogc3RyaW5nOyBzdGF0dXM6IG51bWJlciB9PiB7XG4gIGxldCBsYXN0RXJyOiBhbnk7XG4gIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heDsgYXR0ZW1wdCsrKSB7XG4gICAgY29uc3QgdWEgPSBVU0VSX0FHRU5UU1soYXR0ZW1wdCAtIDEpICUgVVNFUl9BR0VOVFMubGVuZ3RoXTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXhpb3MuZ2V0KHVybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiB1YSxcbiAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOCcsXG4gICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1VUyxlbjtxPTAuOScsXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdSZWZlcmVyJzogbmV3IFVSTCh1cmwpLm9yaWdpbiArICcvJ1xuICAgICAgICB9LFxuICAgICAgICBtYXhSZWRpcmVjdHM6IDUsXG4gICAgICAgIHRpbWVvdXQ6IDEyMDAwLFxuICAgICAgICB2YWxpZGF0ZVN0YXR1czogcyA9PiBzIDwgNTAwIHx8IHMgPT09IDUwMyB8fCBzID09PSA0MjlcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkgcmV0dXJuIHsgaHRtbDogcmVzLmRhdGEsIHN0YXR1czogcmVzLnN0YXR1cyB9O1xuICAgICAgaWYgKFs0MjksIDQwMywgNTAzXS5pbmNsdWRlcyhyZXMuc3RhdHVzKSAmJiBhdHRlbXB0IDwgbWF4KSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCAzNTAgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBodG1sOiByZXMuZGF0YSwgc3RhdHVzOiByZXMuc3RhdHVzIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbGFzdEVyciA9IGU7XG4gICAgICBpZiAoYXR0ZW1wdCA9PT0gbWF4KSB0aHJvdyBlO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UociA9PiBzZXRUaW1lb3V0KHIsIDM1MCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSkpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBsYXN0RXJyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VQcm9kdWN0KHVybDogc3RyaW5nKTogUHJvbWlzZTxQcm9kdWN0RGF0YSAmIHsgX19mZXRjaFN0YXR1cz86IG51bWJlcjsgX19yZWFzb24/OiBzdHJpbmcgfT4ge1xuICBjb25zdCBjbGVhbiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZyA9PlxuICAgICh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG5cbiAgLy8gTm9ybWFsaXNlIGltYWdlIFVSTHMgKHByb3RvY29sLXJlbGF0aXZlLCByb290LXJlbGF0aXZlLCBhbmQgcmVsYXRpdmUgcGF0aHMpXG4gIGNvbnN0IGJ1aWxkTm9ybWFsaXNlciA9IChwYWdlVXJsOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgb3JpZ2luID0gJyc7XG4gICAgbGV0IGJhc2VQYXRoID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKHBhZ2VVcmwpO1xuICAgICAgb3JpZ2luID0gdS5vcmlnaW47XG4gICAgICBiYXNlUGF0aCA9IHBhZ2VVcmwuZW5kc1dpdGgoJy8nKSA/IHBhZ2VVcmwgOiBwYWdlVXJsLnN1YnN0cmluZygwLCBwYWdlVXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9IGNhdGNoIChfKSB7fVxuICAgIHJldHVybiAocmF3OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IChyYXcgfHwgJycpLnRyaW0oKTtcbiAgICAgIGlmICghdmFsKSByZXR1cm4gJyc7XG4gICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdCh2YWwpKSByZXR1cm4gdmFsO1xuICAgICAgaWYgKHZhbC5zdGFydHNXaXRoKCcvLycpKSByZXR1cm4gYGh0dHBzOiR7dmFsfWA7IC8vIGFzc3VtZSBodHRwcyBmb3IgcHJvdG9jb2wtcmVsYXRpdmVcbiAgICAgIGlmICh2YWwuc3RhcnRzV2l0aCgnLycpKSByZXR1cm4gb3JpZ2luID8gb3JpZ2luICsgdmFsIDogdmFsOyAvLyByb290LXJlbGF0aXZlXG4gICAgICByZXR1cm4gYmFzZVBhdGggPyBiYXNlUGF0aCArIHZhbCA6IHZhbDsgLy8gcmVsYXRpdmUgcGF0aFxuICAgIH07XG4gIH07XG4gIGNvbnN0IG5vcm1hbGlzZSA9IGJ1aWxkTm9ybWFsaXNlcih1cmwpO1xuXG4gIGxldCBodG1sID0gJyc7XG4gIGxldCBzdGF0dXMgPSAwO1xuICB0cnkge1xuICAgIGNvbnN0IGZldGNoZWQgPSBhd2FpdCBmZXRjaFdpdGhSZXRyaWVzKHVybCwgMyk7XG4gICAgaHRtbCA9IGZldGNoZWQuaHRtbDtcbiAgICBzdGF0dXMgPSBmZXRjaGVkLnN0YXR1cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHt1cmx9OmAsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICB1cmwsXG4gICAgICBwcmV0aXRsZTogJycsXG4gICAgICB0aXRsZTogJycsXG4gICAgICBwcmljZTogJycsXG4gICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICBpbWFnZTogJycsXG4gICAgICBpbWFnZXM6IHVuZGVmaW5lZCxcbiAgICAgIGN0YTogdXJsLFxuICAgICAgY3RhTGFiZWw6ICdTSE9QIE5PVycsXG4gICAgICBfX2ZldGNoU3RhdHVzOiBzdGF0dXMgfHwgMCxcbiAgICAgIF9fcmVhc29uOiAnZmV0Y2gtZmFpbGVkJ1xuICAgIH0gYXMgYW55O1xuICB9XG5cbiAgY29uc3QgJCA9IGNoZWVyaW8ubG9hZChodG1sKTtcbiAgLy8gUmVtb3ZlIGFueSBtZWdhLW1lbnUgY29udGVudCB0byBhdm9pZCBwb2xsdXRpbmcgZXh0cmFjdGlvblxuICB0cnkge1xuICAgIGNvbnN0IHJlTWVnYSA9IC9tZWdhWy1fIF0/bWVudS9pO1xuICAgIGNvbnN0IHRvUmVtb3ZlID0gJCgnW2NsYXNzXScpLmZpbHRlcigoXywgZWwpID0+IHJlTWVnYS50ZXN0KCgkKGVsKS5hdHRyKCdjbGFzcycpIHx8ICcnKSkpLnRvQXJyYXkoKTtcbiAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSAkKHRvUmVtb3ZlKS5yZW1vdmUoKTtcbiAgfSBjYXRjaCAoXykge31cblxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIEpTT07igJFMRCBzdHJ1Y3R1cmVkIGRhdGEgZmlyc3QgYmVjYXVzZSBpdCB0eXBpY2FsbHlcbiAgLy8gcHJvdmlkZXMgdGhlIHJpY2hlc3QgaW5mb3JtYXRpb24uIFdlIGZhbGwgYmFjayB0byBtZXRhIHRhZ3MgaWZcbiAgLy8gc3RydWN0dXJlZCBkYXRhIGlzIG5vdCBwcmVzZW50IG9yIGluY29tcGxldGUuXG4gIGNvbnN0IGxkID0gcGFyc2VMZEpzb24oJCkgfHwge307XG4gIGNvbnN0IHByb2R1Y3Q6IFByb2R1Y3REYXRhICYgeyBfX2ZldGNoU3RhdHVzPzogbnVtYmVyOyBfX3JlYXNvbj86IHN0cmluZyB9ID0ge1xuICAgIHVybCxcbiAgICBwcmV0aXRsZTogJycsXG4gICAgdGl0bGU6ICcnLFxuICAgIHByaWNlOiAnJyxcbiAgICBvcmlnaW5hbFByaWNlOiB1bmRlZmluZWQsXG4gICAgZGVzY3JpcHRpb246ICcnLFxuICAgIG1ldGFkYXRhRGVzY3JpcHRpb246IHVuZGVmaW5lZCxcbiAgICBpbWFnZTogJycsXG4gICAgaW1hZ2VzOiB1bmRlZmluZWQsXG4gICAgY3RhOiB1cmxcbiAgICAsXG4gICAgLy8gRGVmYXVsdCBjYWxsLXRvLWFjdGlvbiBsYWJlbC4gVXNlcnMgY2FuIG92ZXJyaWRlIHRoaXMgaW4gdGhlXG4gICAgLy8gcHJldmlldyBieSBlZGl0aW5nIHRoZSBDVEEgdGV4dC4gSWYgbm90IHByb3ZpZGVkLCB0ZW1wbGF0ZXNcbiAgICAvLyB3aWxsIGZhbGwgYmFjayB0byB0aGlzIHZhbHVlLlxuICAgIGN0YUxhYmVsOiAnU0hPUCBOT1cnXG4gIH07XG4gIHByb2R1Y3QuX19mZXRjaFN0YXR1cyA9IHN0YXR1cztcblxuICAvLyBUaXRsZVxuICBwcm9kdWN0LnRpdGxlID1cbiAgICBjbGVhbihsZC5uYW1lKSB8fFxuICAgIGNsZWFuKGdldE1ldGEoJCwgJ29nOnRpdGxlJykpIHx8XG4gICAgY2xlYW4oZ2V0TWV0YSgkLCAndHdpdHRlcjp0aXRsZScpKSB8fFxuICAgIGNsZWFuKCQoJ3RpdGxlJykuZmlyc3QoKS50ZXh0KCkpO1xuXG4gIC8vIERlc2NyaXB0aW9uICYgbWV0YWRhdGEgZGVzY3JpcHRpb25cbiAgLy8gV2UgZGlzdGluZ3Vpc2ggdGhlIHBhZ2UncyBjYW5vbmljYWwgTUVUQSBkZXNjcmlwdGlvbiAoPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCI+KVxuICAvLyBmcm9tIG90aGVyIHBvdGVudGlhbCBzb3VyY2VzIGxpa2UgSlNPTi1MRCBQcm9kdWN0LmRlc2NyaXB0aW9uIG9yIE9wZW4gR3JhcGggLyBUd2l0dGVyXG4gIC8vIGRlc2NyaXB0aW9ucy4gUGVyIHJlcXVpcmVtZW50OiBtZXRhZGF0YURlc2NyaXB0aW9uIG11c3Qgb3JpZ2luYXRlIGZyb20gdGhlIG1ldGEgdGFnIG9ubHkuXG4gIGNvbnN0IG1ldGFUYWdEZXNjcmlwdGlvbiA9IGNsZWFuKGdldE1ldGEoJCwgJ2Rlc2NyaXB0aW9uJykpO1xuICBjb25zdCBsZERlc2MgPSBjbGVhbihsZC5kZXNjcmlwdGlvbik7XG4gIGNvbnN0IG9nRGVzYyA9IGNsZWFuKGdldE1ldGEoJCwgJ29nOmRlc2NyaXB0aW9uJykpO1xuICBjb25zdCB0d2l0dGVyRGVzYyA9IGNsZWFuKGdldE1ldGEoJCwgJ3R3aXR0ZXI6ZGVzY3JpcHRpb24nKSk7XG5cbiAgLy8gQXNzaWduIG9ubHkgdGhlIGxpdGVyYWwgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCI+IGNvbnRlbnQgdG8gbWV0YWRhdGFEZXNjcmlwdGlvblxuICBwcm9kdWN0Lm1ldGFkYXRhRGVzY3JpcHRpb24gPSBtZXRhVGFnRGVzY3JpcHRpb24gfHwgdW5kZWZpbmVkO1xuICBpZiAobWV0YVRhZ0Rlc2NyaXB0aW9uKSB7XG4gICAgKHByb2R1Y3QgYXMgYW55KS5vcmlnaW5hbE1ldGFkYXRhRGVzY3JpcHRpb24gPSBtZXRhVGFnRGVzY3JpcHRpb247XG4gIH1cbiAgLy8gRGVmYXVsdCB1c2VyLWZhY2luZyBkZXNjcmlwdGlvbiBwcmVmZXJzIHRoZSBtZXRhIHRhZywgdGhlbiBzdHJ1Y3R1cmVkIGRhdGEsIHRoZW4gT0cvVHdpdHRlci5cbiAgcHJvZHVjdC5kZXNjcmlwdGlvbiA9IG1ldGFUYWdEZXNjcmlwdGlvbiB8fCBsZERlc2MgfHwgb2dEZXNjIHx8IHR3aXR0ZXJEZXNjIHx8ICcnO1xuXG4gIC8vIEV4dHJhY3Qgc3BlY2lmaWMgZGVzY3JpcHRpb24gc291cmNlcyBmcm9tIC5wcm9kdWN0X19kZXNjcmlwdGlvblxuICB0cnkge1xuICAgIGNvbnN0IGRlc2NSb290ID0gJCgnLnByb2R1Y3RfX2Rlc2NyaXB0aW9uJykuZmlyc3QoKTtcbiAgICBpZiAoZGVzY1Jvb3QgJiYgZGVzY1Jvb3QubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwID0gZGVzY1Jvb3QuZmluZCgncCcpLmZpcnN0KCk7XG4gICAgICBpZiAocCAmJiBwLmxlbmd0aCkge1xuICAgICAgICBwcm9kdWN0LmRlc2NyaXB0aW9uUCA9IGNsZWFuKHAudGV4dCgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVsID0gZGVzY1Jvb3QuZmluZCgndWwnKS5maXJzdCgpO1xuICAgICAgaWYgKHVsICYmIHVsLmxlbmd0aCkge1xuICAgICAgICAvLyBQcmVzZXJ2ZSBVTCBzdHJ1Y3R1cmUgYXMgSFRNTCBmb3IgZW1haWwgcHJldmlldy90ZW1wbGF0ZVxuICAgICAgICBwcm9kdWN0LmRlc2NyaXB0aW9uVWwgPSAkLmh0bWwodWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlnbm9yZSBleHRyYWN0aW9uIGVycm9yc1xuICB9XG5cbiAgLy8gSW1hZ2VcbiAgY29uc3QgbGRJbWFnZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gQXJyYXkuaXNBcnJheShsZC5pbWFnZSlcbiAgICA/IGxkLmltYWdlWzBdXG4gICAgOiB0eXBlb2YgbGQuaW1hZ2UgPT09ICdzdHJpbmcnXG4gICAgPyBsZC5pbWFnZVxuICAgIDogdW5kZWZpbmVkO1xuICAvLyBDb2xsZWN0IHBvc3NpYmxlIGltYWdlIGNhbmRpZGF0ZXMgaW5jbHVkaW5nIGxhenkgYXR0cnMgJiBzcmNzZXRcbiAgY29uc3QgZmlyc3RJbWcgPSAkKCdpbWcnKS5maXJzdCgpO1xuICBjb25zdCBzcmNzZXQgPSBmaXJzdEltZy5hdHRyKCdzcmNzZXQnKTtcbiAgbGV0IHNyY3NldFBpY2sgPSAnJztcbiAgaWYgKHNyY3NldCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBjaG9vc2UgbGFyZ2VzdCBkZXNjcmlwdG9yXG4gICAgICBjb25zdCBwYXJ0cyA9IHNyY3NldC5zcGxpdCgnLCcpLm1hcChwID0+IHAudHJpbSgpKTtcbiAgICAgIGxldCBiZXN0VyA9IC0xO1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIGNvbnN0IG0gPSBwYXJ0Lm1hdGNoKC9cXHMrKFxcZCspW3d4XSQvKTtcbiAgICAgICAgY29uc3QgdXJsUGFydCA9IHBhcnQucmVwbGFjZSgvXFxzKyhcXGQrKVt3eF0kLywgJycpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdyA9IG0gPyBwYXJzZUludChtWzFdLCAxMCkgOiAwO1xuICAgICAgICBpZiAodyA+IGJlc3RXKSB7IGJlc3RXID0gdzsgc3Jjc2V0UGljayA9IHVybFBhcnQ7IH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIHt9XG4gIH1cbiAgcHJvZHVjdC5pbWFnZSA9IG5vcm1hbGlzZShcbiAgICBjbGVhbihsZEltYWdlKSB8fFxuICAgICAgY2xlYW4oZ2V0TWV0YSgkLCAnb2c6aW1hZ2U6c2VjdXJlX3VybCcpKSB8fFxuICAgICAgY2xlYW4oZ2V0TWV0YSgkLCAnb2c6aW1hZ2UnKSkgfHxcbiAgICAgIGNsZWFuKGdldE1ldGEoJCwgJ3R3aXR0ZXI6aW1hZ2UnKSkgfHxcbiAgICAgIGNsZWFuKGZpcnN0SW1nLmF0dHIoJ2RhdGEtc3JjJykpIHx8XG4gICAgICBjbGVhbihmaXJzdEltZy5hdHRyKCdkYXRhLWxhenknKSkgfHxcbiAgICAgIGNsZWFuKHNyY3NldFBpY2spIHx8XG4gICAgICBjbGVhbihmaXJzdEltZy5hdHRyKCdzcmMnKSlcbiAgKTtcblxuICAvLyBQcmljZVxuICBjb25zdCBsZE9mZmVycyA9IGxkLm9mZmVycztcbiAgbGV0IGxkUHJpY2U6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaWYgKGxkT2ZmZXJzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGRPZmZlcnMpKSB7XG4gICAgICBsZFByaWNlID0gbGRPZmZlcnNbMF0/LnByaWNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxkT2ZmZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgbGRQcmljZSA9IGxkT2ZmZXJzLnByaWNlO1xuICAgIH1cbiAgfVxuICBwcm9kdWN0LnByaWNlID1cbiAgICBjbGVhbihsZFByaWNlKSB8fFxuICAgIGNsZWFuKGdldE1ldGEoJCwgJ3Byb2R1Y3Q6cHJpY2U6YW1vdW50JykpIHx8XG4gICAgY2xlYW4oZ2V0TWV0YSgkLCAnb2c6cHJpY2U6YW1vdW50JykpIHx8XG4gICAgLy8gVHJ5IHRvIG1hdGNoIG1pY3JvZGF0YSBvbiBzaXRlcyBsaWtlIFNob3BpZnk6IFtpdGVtcHJvcD1cInByaWNlXCJdXG4gICAgY2xlYW4oJCgnW2l0ZW1wcm9wPVwicHJpY2VcIl0nKS5maXJzdCgpLnRleHQoKSk7XG5cbiAgLy8gT3JpZ2luYWwgcHJpY2U6IGF0dGVtcHQgdG8gZmluZCBhIGNvbXBhcmXigJFhdCBvciBzdHJpa2XigJF0aHJvdWdoIHByaWNlLiBUaGlzXG4gIC8vIGNhbiBhcHBlYXIgaW4gSlNPTuKAkUxEIGFzIGFuIFwicHJpY2VTcGVjaWZpY2F0aW9uXCIgd2l0aFxuICAvLyBcInByaWNlQ3VycmVuY3lcIiBhbmQgXCJ2YWx1ZVwiLCBvciBpbiB0aGUgRE9NIGFzIDxkZWw+IG9yIGEgc3BhbiB3aXRoXG4gIC8vIGNsYXNzIGNvbnRhaW5pbmcgXCJjb21wYXJlXCIgb3IgXCJzdHJpa2VcIi4gV2UgYXR0ZW1wdCBzZXZlcmFsIGhldXJpc3RpY3NcbiAgLy8gYW5kIHRha2UgdGhlIGZpcnN0IG51bWVyaWMgdmFsdWUgd2UgZmluZC4gVGhlIHZhbHVlIHJldHVybmVkIGRvZXNcbiAgLy8gbm90IGluY2x1ZGUgdGhlIGN1cnJlbmN5IHN5bWJvbC5cbiAgbGV0IG9yaWdpbmFsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8vIENoZWNrIEpTT07igJFMRCBvZmZlcnMuY29tcGFyZVByaWNlIGlmIHByZXNlbnRcbiAgaWYgKGxkT2ZmZXJzKSB7XG4gICAgLy8gU29tZSBzY2hlbWFzIG5lc3QgY29tcGFyZUF0UHJpY2Ugb3Igb3JpZ2luYWxQcmljZVxuICAgIGNvbnN0IGdldENvbXBhcmUgPSAob2JqOiBhbnkpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqLmNvbXBhcmVBdFByaWNlIHx8IG9iai5vcmlnaW5hbFByaWNlIHx8IG9iai5wcmljZVNwZWNpZmljYXRpb24/LnByaWNlO1xuICAgIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGRPZmZlcnMpKSB7XG4gICAgICBmb3IgKGNvbnN0IG9mZiBvZiBsZE9mZmVycykge1xuICAgICAgICBjb25zdCB2YWwgPSBnZXRDb21wYXJlKG9mZik7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBvcmlnaW5hbCA9IGNsZWFuKHZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZE9mZmVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGdldENvbXBhcmUobGRPZmZlcnMpO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICBvcmlnaW5hbCA9IGNsZWFuKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghb3JpZ2luYWwpIHtcbiAgICAvLyBMb29rIGZvciBlbGVtZW50cyBjb250YWluaW5nIGEgcHJpY2Ugd2l0aCBhIGxpbmXigJF0aHJvdWdoIHN0eWxlIG9yIGFcbiAgICAvLyBjbGFzcyBpbmRpY2F0aW5nIFwiY29tcGFyZVwiIG9yIFwib3JpZ2luYWxcIi4gV2UgZXh0cmFjdCBudW1lcmljXG4gICAgLy8gdmFsdWVzIChkaWdpdHMgYW5kIGRlY2ltYWwgc2VwYXJhdG9ycykuXG4gICAgY29uc3QgcHJpY2VSZWdleCA9IC8oW1xcZCwuXSspXFxzKig/OltBLVpdezN9KT8vO1xuICAgIC8vIGhlbHBlciB0byBwYXJzZSB0ZXh0XG4gICAgY29uc3QgcGFyc2VQcmljZVRleHQgPSAodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IHByaWNlUmVnZXguZXhlYyh0ZXh0KTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLy8gQ2hlY2sgPGRlbD4gZWxlbWVudHNcbiAgICAkKCdkZWwsIHN0cmlrZScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gJChlbCkudGV4dCgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VQcmljZVRleHQodGV4dCk7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIG9yaWdpbmFsID0gY2xlYW4odmFsKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBicmVhayB0aGUgbG9vcFxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIENoZWNrIGVsZW1lbnRzIHdpdGggY2xhc3MgY29udGFpbmluZyBjb21wYXJlIG9yIG9yaWdpbmFsXG4gICAgaWYgKCFvcmlnaW5hbCkge1xuICAgICAgJCgnW2NsYXNzKj1cImNvbXBhcmVcIl0sW2NsYXNzKj1cIm9yaWdpbmFsXCJdLFtjbGFzcyo9XCJzdHJpa2VcIl0nKS5lYWNoKChfLCBlbCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0gJChlbCkudGV4dCgpO1xuICAgICAgICBjb25zdCB2YWwgPSBwYXJzZVByaWNlVGV4dCh0ZXh0KTtcbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIG9yaWdpbmFsID0gY2xlYW4odmFsKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyBBc3NpZ24gb3JpZ2luYWxQcmljZSBpZiBmb3VuZCBhbmQgZGlmZmVyZW50IGZyb20gc2FsZSBwcmljZVxuICBpZiAob3JpZ2luYWwgJiYgb3JpZ2luYWwgIT09IHByb2R1Y3QucHJpY2UpIHtcbiAgICBwcm9kdWN0Lm9yaWdpbmFsUHJpY2UgPSBvcmlnaW5hbDtcbiAgfVxuXG4gIC8vIFByZXRpdGxlOiBub3Qgd2lkZWx5IGF2YWlsYWJsZS4gQXMgYSBoZXVyaXN0aWMsIGlmIHRoZSB0aXRsZVxuICAvLyBjb250YWlucyBhIGh5cGhlbiwgc3BsaXQgdGhlIGZpcnN0IHBhcnQgYXMgcHJldGl0bGUgYW5kIHRoZSByZXN0XG4gIC8vIGFzIHRoZSBhY3R1YWwgdGl0bGUuXG4gIGlmIChwcm9kdWN0LnRpdGxlICYmIHByb2R1Y3QudGl0bGUuaW5jbHVkZXMoJyDigJMgJykpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHByb2R1Y3QudGl0bGUuc3BsaXQoL1xccyvigJNcXHMrLyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHByb2R1Y3QucHJldGl0bGUgPSBwYXJ0c1swXTtcbiAgICAgIHByb2R1Y3QudGl0bGUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKCcg4oCTICcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbG91ciBjYXB0dXJlIHJlbW92ZWQgcGVyIHJlZmFjdG9yOyBubyBzd2F0Y2ggZGV0ZWN0aW9uXG5cbiAgLy8gSW1hZ2VzOiBjb2xsZWN0IGFkZGl0aW9uYWwgaW1hZ2UgVVJMcyBiZXlvbmQgdGhlIHByaW1hcnkgaW1hZ2UuIFdlXG4gIC8vIHN0YXJ0IHdpdGggdGhlIHByaW1hcnkgaW1hZ2UgaWYgaXQgZXhpc3RzLiBUaGVuIHNlYXJjaCBmb3IgaW1hZ2VcbiAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGlrZWx5IHBhcnQgb2YgdGhlIHByb2R1Y3QgZ2FsbGVyeS4gSGV1cmlzdGljc1xuICAvLyBpbmNsdWRlIGNsYXNzIG5hbWVzIGNvbnRhaW5pbmcgXCJwcm9kdWN0XCIsIFwiZ2FsbGVyeVwiLCBcInRodW1iXCIsIG9yXG4gIC8vIFwiaW1hZ2VcIi4gV2UgYWxzbyBhY2NlcHQgSlNPTuKAkUxEIGltYWdlIGFycmF5cy4gT25seSBhYnNvbHV0ZVxuICAvLyBVUkxzIChodHRwIG9yIGh0dHBzKSBhcmUga2VwdCBhbmQgZHVwbGljYXRlcyByZW1vdmVkLlxuICBjb25zdCBpbWFnZVNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBpZiAocHJvZHVjdC5pbWFnZSkge1xuICAgIGltYWdlU2V0LmFkZChwcm9kdWN0LmltYWdlKTtcbiAgfVxuICAvLyBBZGQgYW55IGFkZGl0aW9uYWwgaW1hZ2VzIGZyb20gSlNPTuKAkUxEXG4gIGlmIChBcnJheS5pc0FycmF5KGxkLmltYWdlKSkge1xuICAgIGZvciAoY29uc3QgaW1nIG9mIGxkLmltYWdlKSB7XG4gICAgICBpZiAodHlwZW9mIGltZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW1hZ2VTZXQuYWRkKG5vcm1hbGlzZShpbWcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRE9NIGV4dHJhY3Rpb246IGZpbmQgaW1hZ2VzIHdpdGggcmVsZXZhbnQgY2xhc3MgaGludHNcbiAgJCgnaW1nJykuZWFjaCgoXywgZWwpID0+IHtcbiAgICBjb25zdCBzcmMgPSBub3JtYWxpc2UoJChlbCkuYXR0cignc3JjJykpO1xuICAgIGlmICghc3JjKSByZXR1cm47XG4gICAgaWYgKCEvXFwuKGpwZT9nfHBuZ3xnaWZ8d2VicHxhdmlmfHN2ZykoPzpbPyNdLiopPyQvaS50ZXN0KHNyYykpIHJldHVybjtcbiAgICAvLyBBY2NlcHQgaW1hZ2VzIGlmIHRoZXkgY29udGFpbiBjZXJ0YWluIGtleXdvcmRzIGluIHRoZWlyIGNsYXNzIG9yIGlkXG4gICAgY29uc3QgY2xhc3NlcyA9ICgkKGVsKS5hdHRyKCdjbGFzcycpIHx8ICcnKSArICcgJyArICgkKGVsKS5wYXJlbnQoKS5hdHRyKCdjbGFzcycpIHx8ICcnKTtcbiAgICBjb25zdCBpZHMgPSAoJChlbCkuYXR0cignaWQnKSB8fCAnJykgKyAnICcgKyAoJChlbCkucGFyZW50KCkuYXR0cignaWQnKSB8fCAnJyk7XG4gICAgY29uc3QgaGF5ID0gY2xhc3NlcyArICcgJyArIGlkcztcbiAgICBpZiAoL3Byb2R1Y3R8Z2FsbGVyeXx0aHVtYnxpbWFnZXxzbGlkZXJ8Y2Fyb3VzZWwvaS50ZXN0KGhheSkpIHtcbiAgICAgIGltYWdlU2V0LmFkZChzcmMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWRkaXRpb25hbCBleHRyYWN0aW9uOiBhdHRlbXB0IHRvIGZldGNoIHRoZSBTaG9waWZ5IC5qcyBlbmRwb2ludCBmb3JcbiAgLy8gcmljaGVyIHByb2R1Y3QgZGF0YS4gTWFueSBTaG9waWZ5IHN0b3JlcyBleHBvc2UgYSBKU09OIGZpbGUgYXRcbiAgLy8gPHByb2R1Y3QtdXJsPi5qcyB3aGljaCBjb250YWlucyBhbiBhcnJheSBvZiBpbWFnZSBVUkxzIGFuZCB0aGVcbiAgLy8gZmVhdHVyZWQgaW1hZ2UuIElmIHRoZSByZXF1ZXN0IGZhaWxzIG9yIHRoZSByZXNwb25zZSBpcyBub3QgSlNPTixcbiAgLy8gd2Ugc2lsZW50bHkgaWdub3JlIGl0LiBXZSBwcmVmaXggcHJvdG9jb2wtcmVsYXRpdmUgVVJMcyB3aXRoXG4gIC8vIGh0dHBzOiB0byBlbnN1cmUgYWJzb2x1dGUgcGF0aHMuIEFueSBpbWFnZXMgZm91bmQgaGVyZSBhcmUgYWRkZWRcbiAgLy8gdG8gaW1hZ2VTZXQuIFRoaXMgbG9naWMgbWlycm9ycyB0aGUgd29ya2luZyBpbXBsZW1lbnRhdGlvbiBmcm9tXG4gIC8vIHRoZSBwcm92aWRlZCByZWZlcmVuY2UgcGFja2FnZS4gSXQgYXZvaWRzIHNsaWNpbmcgdGhlIEpTT04gYnlcbiAgLy8gYnJhY2VzIGFuZCBpbnN0ZWFkIGxldHMgSlNPTi5wYXJzZSBoYW5kbGUgdGhlIHN0cmluZy5cbiAgdHJ5IHtcbiAgICBjb25zdCBqc1VybCA9IHVybC5lbmRzV2l0aCgnLmpzJykgPyB1cmwgOiBgJHt1cmx9LmpzYDtcbiAgICBjb25zdCBqc1Jlc3AgPSBhd2FpdCBheGlvcy5nZXQoanNVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1VzZXItQWdlbnQnOlxuICAgICAgICAgICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTE2LjAgU2FmYXJpLzUzNy4zNidcbiAgICAgIH0sXG4gICAgICBtYXhSZWRpcmVjdHM6IDNcbiAgICB9KTtcbiAgICBjb25zdCBqc0RhdGEgPSBqc1Jlc3AuZGF0YTtcbiAgICAvLyBJZiByZXNwb25zZSBpcyBhIHN0cmluZywgYXR0ZW1wdCB0byBwYXJzZSBKU09OOyBpZiBpdCdzIGFscmVhZHlcbiAgICAvLyBhbiBvYmplY3Qgd2UgY2FuIHByb2Nlc3MgaXQgZGlyZWN0bHkuIFNvbWUgcGxhdGZvcm1zIGVzY2FwZVxuICAgIC8vIHVuaWNvZGUgc2VxdWVuY2VzLCBidXQgSlNPTi5wYXJzZSB3aWxsIGhhbmRsZSB0aGVtLlxuICAgIGNvbnN0IHBhcnNlZERhdGEgPVxuICAgICAgdHlwZW9mIGpzRGF0YSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBKU09OLnBhcnNlKGpzRGF0YSlcbiAgICAgICAgOiB0eXBlb2YganNEYXRhID09PSAnb2JqZWN0J1xuICAgICAgICA/IGpzRGF0YVxuICAgICAgICA6IG51bGw7XG4gICAgaWYgKHBhcnNlZERhdGEgJiYgdHlwZW9mIHBhcnNlZERhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBFeHRyYWN0IGltYWdlcyBhcnJheVxuICAgICAgY29uc3QgaW1nczogdW5rbm93biA9IChwYXJzZWREYXRhIGFzIGFueSkuaW1hZ2VzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW1ncykpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIGltZ3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnICYmIHApIHtcbiAgICAgICAgICAgIGNvbnN0IGltZ1VybCA9IG5vcm1hbGlzZShwLnN0YXJ0c1dpdGgoJy8vJykgPyBgaHR0cHM6JHtwfWAgOiBwKTtcbiAgICAgICAgICAgIGlmIChpbWdVcmwpIHtcbiAgICAgICAgICAgICAgaW1hZ2VTZXQuYWRkKGltZ1VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBFeHRyYWN0IGZlYXR1cmVkIGltYWdlXG4gICAgICBjb25zdCBmZWF0OiB1bmtub3duID0gKHBhcnNlZERhdGEgYXMgYW55KS5mZWF0dXJlZF9pbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgZmVhdCA9PT0gJ3N0cmluZycgJiYgZmVhdCkge1xuICAgICAgICBjb25zdCBmdWxsID0gbm9ybWFsaXNlKGZlYXQuc3RhcnRzV2l0aCgnLy8nKSA/IGBodHRwczoke2ZlYXR9YCA6IGZlYXQpO1xuICAgICAgICBpZiAoZnVsbCkge1xuICAgICAgICAgIGltYWdlU2V0LmFkZChmdWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gU2lsZW50bHkgaWdub3JlIGVycm9yczsgdGhlIEpTT04gZW5kcG9pbnQgbWF5IG5vdCBleGlzdCBvciBtYXkgbm90XG4gICAgLy8gcmV0dXJuIHZhbGlkIEpTT04uIEluIHN1Y2ggY2FzZXMgd2Ugc2ltcGx5IHJlbHkgb24gaW1hZ2VzXG4gICAgLy8gZXh0cmFjdGVkIGZyb20gdGhlIEhUTUwgYW5kIEpTT04tTEQuXG4gIH1cbiAgLy8gQXNzaWduIGltYWdlcyBhcnJheSBpZiBtb3JlIHRoYW4gb25lIGltYWdlIGlzIGZvdW5kXG4gIGNvbnN0IGltYWdlc0FyciA9IEFycmF5LmZyb20oaW1hZ2VTZXQpO1xuICBpZiAoaW1hZ2VzQXJyLmxlbmd0aCA+IDApIHtcbiAgICAvLyBBc3NpZ24gdGhlIGltYWdlcyBkaXJlY3RseSBmcm9tIGltYWdlU2V0LiBUaGUgaW1hZ2VTZXQgaXRzZWxmXG4gICAgLy8gYWxyZWFkeSBkZWR1cGxpY2F0ZXMgZXhhY3QgVVJMcyB3aGlsZSBwcmVzZXJ2aW5nIGluc2VydGlvbiBvcmRlci5cbiAgICAvLyBXZSBubyBsb25nZXIgZGVkdXBsaWNhdGUgYnkgYmFzZSBwYXRoIChxdWVyeSBwYXJhbWV0ZXJzKSBiZWNhdXNlXG4gICAgLy8gc29tZSBzdG9yZXMgdXNlIHRoZSBzYW1lIGJhc2UgZm9yIGRpZmZlcmVudCBpbWFnZXMuIEluc3RlYWQgd2VcbiAgICAvLyBwcmVzZXJ2ZSBhbGwgdW5pcXVlIFVSTHMuIFdlIHN0aWxsIG1vdmUgdGhlIHByaW1hcnkgaW1hZ2UgdG9cbiAgICAvLyB0aGUgZnJvbnQgb2YgdGhlIGFycmF5IGlmIGl0IGV4aXN0cyBhbmQgaXMgbm90IGFscmVhZHkgZmlyc3QuXG4gICAgbGV0IGRlZHVwZWQ6IHN0cmluZ1tdID0gaW1hZ2VzQXJyO1xuICAgIGlmIChwcm9kdWN0LmltYWdlKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGRlZHVwZWQuZmluZEluZGV4KChpKSA9PiBpID09PSBwcm9kdWN0LmltYWdlKTtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgW2ltZ10gPSBkZWR1cGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGRlZHVwZWQudW5zaGlmdChpbWcpO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgZGVkdXBlZC51bnNoaWZ0KHByb2R1Y3QuaW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9kdWN0LmltYWdlcyA9IGRlZHVwZWQ7XG4gIH1cblxuICAvLyBJZiB3ZSBmYWlsZWQgc3RydWN0dXJlZCBleHRyYWN0aW9uLCBhdHRlbXB0IGVtYmVkZGVkIHNjcmlwdCBkYXRhc2V0cyAoTmV4dC5qcyAvIE51eHQgLyBldGMuKVxuICB0cnkge1xuICAgIGlmICghcHJvZHVjdC50aXRsZSkge1xuICBjb25zdCBuZXh0TWF0Y2ggPSBodG1sLm1hdGNoKC9fX05FWFRfREFUQV9fXFxzKj1cXHMqKFxce1tcXHNcXFNdKj9cXH0pXFxzKjxcXC9zY3JpcHQ+Lyk7XG4gICAgICBpZiAobmV4dE1hdGNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShuZXh0TWF0Y2hbMV0pO1xuICAgICAgICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgICAgLy8gbmFpdmUgZmluZCBvZiBwcm9kdWN0IHRpdGxlIGtleXNcbiAgICAgICAgICBjb25zdCB0aXRsZU1hdGNoID0gc3RyLm1hdGNoKC9cInRpdGxlXCJcXHMqOlxccypcIihbXlwiXXs1LH0pXCIvKTtcbiAgICAgICAgICBpZiAodGl0bGVNYXRjaCkgcHJvZHVjdC50aXRsZSA9IGNsZWFuKHRpdGxlTWF0Y2hbMV0pO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHt9XG5cbiAgLy8gTWFyayByZWFzb24gaWYgbm90aGluZyBtZWFuaW5nZnVsXG4gIGNvbnN0IG1lYW5pbmdmdWxLZXlzID0gWyd0aXRsZScsJ2Rlc2NyaXB0aW9uJywnaW1hZ2UnLCdwcmljZScsJ29yaWdpbmFsUHJpY2UnLCdpbWFnZXMnLCdwcmV0aXRsZSddO1xuICBjb25zdCBoYXNJbmZvID0gbWVhbmluZ2Z1bEtleXMuc29tZShrID0+IHtcbiAgICBjb25zdCB2OiBhbnkgPSAocHJvZHVjdCBhcyBhbnkpW2tdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdi5sZW5ndGggPiAwIDogQm9vbGVhbih2ICYmIFN0cmluZyh2KS50cmltKCkpO1xuICB9KTtcbiAgaWYgKCFoYXNJbmZvKSB7XG4gICAgcHJvZHVjdC5fX3JlYXNvbiA9IHByb2R1Y3QuX19yZWFzb24gfHwgKHByb2R1Y3QuX19mZXRjaFN0YXR1cyAmJiBbNDAzLDQyOV0uaW5jbHVkZXMocHJvZHVjdC5fX2ZldGNoU3RhdHVzKSA/ICdibG9ja2VkJyA6ICdlbXB0eScpO1xuICB9XG4gIHJldHVybiBwcm9kdWN0O1xufVxuIl0sIm5hbWVzIjpbImF4aW9zIiwiY2hlZXJpbyIsInBhcnNlTGRKc29uIiwiJCIsInNjcmlwdHMiLCJ0b0FycmF5IiwiZWwiLCJjb250ZW50cyIsInRleHQiLCJqc29uIiwiSlNPTiIsInBhcnNlIiwidHJpbSIsImNhbmRpZGF0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJvYmoiLCJfIiwiZ2V0TWV0YSIsInByb3AiLCJhdHRyIiwiVVNFUl9BR0VOVFMiLCJmZXRjaFdpdGhSZXRyaWVzIiwidXJsIiwibWF4IiwibGFzdEVyciIsImF0dGVtcHQiLCJ1YSIsImxlbmd0aCIsInJlcyIsImdldCIsImhlYWRlcnMiLCJVUkwiLCJvcmlnaW4iLCJtYXhSZWRpcmVjdHMiLCJ0aW1lb3V0IiwidmFsaWRhdGVTdGF0dXMiLCJzIiwic3RhdHVzIiwiaHRtbCIsImRhdGEiLCJpbmNsdWRlcyIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsIk1hdGgiLCJwb3ciLCJlIiwicGFyc2VQcm9kdWN0IiwiY2xlYW4iLCJ2YWx1ZSIsInRvU3RyaW5nIiwiYnVpbGROb3JtYWxpc2VyIiwicGFnZVVybCIsImJhc2VQYXRoIiwidSIsImVuZHNXaXRoIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJyYXciLCJ2YWwiLCJ0ZXN0Iiwic3RhcnRzV2l0aCIsIm5vcm1hbGlzZSIsImZldGNoZWQiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJwcmV0aXRsZSIsInRpdGxlIiwicHJpY2UiLCJkZXNjcmlwdGlvbiIsImltYWdlIiwiaW1hZ2VzIiwidW5kZWZpbmVkIiwiY3RhIiwiY3RhTGFiZWwiLCJfX2ZldGNoU3RhdHVzIiwiX19yZWFzb24iLCJsb2FkIiwicmVNZWdhIiwidG9SZW1vdmUiLCJmaWx0ZXIiLCJyZW1vdmUiLCJsZCIsInByb2R1Y3QiLCJvcmlnaW5hbFByaWNlIiwibWV0YWRhdGFEZXNjcmlwdGlvbiIsIm5hbWUiLCJmaXJzdCIsIm1ldGFUYWdEZXNjcmlwdGlvbiIsImxkRGVzYyIsIm9nRGVzYyIsInR3aXR0ZXJEZXNjIiwib3JpZ2luYWxNZXRhZGF0YURlc2NyaXB0aW9uIiwiZGVzY1Jvb3QiLCJwIiwiZmluZCIsImRlc2NyaXB0aW9uUCIsInVsIiwiZGVzY3JpcHRpb25VbCIsImxkSW1hZ2UiLCJmaXJzdEltZyIsInNyY3NldCIsInNyY3NldFBpY2siLCJwYXJ0cyIsInNwbGl0IiwibWFwIiwiYmVzdFciLCJwYXJ0IiwibSIsIm1hdGNoIiwidXJsUGFydCIsInJlcGxhY2UiLCJ3IiwicGFyc2VJbnQiLCJsZE9mZmVycyIsIm9mZmVycyIsImxkUHJpY2UiLCJvcmlnaW5hbCIsImdldENvbXBhcmUiLCJjb21wYXJlQXRQcmljZSIsInByaWNlU3BlY2lmaWNhdGlvbiIsIm9mZiIsInByaWNlUmVnZXgiLCJwYXJzZVByaWNlVGV4dCIsImV4ZWMiLCJlYWNoIiwic2xpY2UiLCJqb2luIiwiaW1hZ2VTZXQiLCJTZXQiLCJhZGQiLCJpbWciLCJzcmMiLCJjbGFzc2VzIiwicGFyZW50IiwiaWRzIiwiaGF5IiwianNVcmwiLCJqc1Jlc3AiLCJqc0RhdGEiLCJwYXJzZWREYXRhIiwiaW1ncyIsImltZ1VybCIsImZlYXQiLCJmZWF0dXJlZF9pbWFnZSIsImZ1bGwiLCJlcnIiLCJpbWFnZXNBcnIiLCJmcm9tIiwiZGVkdXBlZCIsImluZGV4IiwiZmluZEluZGV4IiwiaSIsInNwbGljZSIsInVuc2hpZnQiLCJuZXh0TWF0Y2giLCJzdHIiLCJzdHJpbmdpZnkiLCJ0aXRsZU1hdGNoIiwibWVhbmluZ2Z1bEtleXMiLCJoYXNJbmZvIiwic29tZSIsImsiLCJ2IiwiQm9vbGVhbiIsIlN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/parser.ts\n");

/***/ }),

/***/ "(api)/./pages/api/analyze.ts":
/*!******************************!*\
  !*** ./pages/api/analyze.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var cheerio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheerio */ \"cheerio\");\n/* harmony import */ var _lib_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/parser */ \"(api)/./lib/parser.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([axios__WEBPACK_IMPORTED_MODULE_0__, cheerio__WEBPACK_IMPORTED_MODULE_1__, _lib_parser__WEBPACK_IMPORTED_MODULE_2__]);\n([axios__WEBPACK_IMPORTED_MODULE_0__, cheerio__WEBPACK_IMPORTED_MODULE_1__, _lib_parser__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\nfunction absoluteUrl(base, url) {\n    if (!url) return \"\";\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) return url;\n    if (url.startsWith(\"//\")) return \"https:\" + url;\n    if (url.startsWith(\"/\")) return new URL(base).origin + url;\n    try {\n        return new URL(url, base).toString();\n    } catch  {\n        return url;\n    }\n}\nfunction rgbToHex(input) {\n    // supports rgb(a) like rgb(255,0,0) or rgba(255,0,0,1)\n    const m = input.match(/rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})/i);\n    if (!m) return null;\n    const r = Math.max(0, Math.min(255, parseInt(m[1], 10)));\n    const g = Math.max(0, Math.min(255, parseInt(m[2], 10)));\n    const b = Math.max(0, Math.min(255, parseInt(m[3], 10)));\n    const toHex = (n)=>n.toString(16).padStart(2, \"0\").toUpperCase();\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n}\nfunction normalizeColor(val) {\n    if (!val) return null;\n    const cleaned = val.trim().replace(/!important/i, \"\").trim();\n    if (/^var\\(/i.test(cleaned)) return null;\n    if (/^transparent$/i.test(cleaned)) return null;\n    if (/^currentColor$/i.test(cleaned)) return null;\n    // hex\n    const hex = cleaned.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i)?.[0];\n    if (hex) return hex.toUpperCase();\n    // rgb/rgba\n    const asHex = rgbToHex(cleaned);\n    if (asHex) return asHex;\n    return null;\n}\n// Extract color candidates from CSS and inline styles for announcement bars and CTAs\nfunction extractColorCandidates($, baseCssTexts) {\n    const candidates = [];\n    const push = (source, color)=>{\n        const c = color && normalizeColor(color);\n        if (!c) return;\n        candidates.push({\n            source,\n            color: c\n        });\n    };\n    // From inline styles of announcement elements\n    $('[class*=\"announcement\" i], [class*=\"anouncement\" i]').each((_, el)=>{\n        const style = ($(el).attr(\"style\") || \"\").toString();\n        const mBg = style.match(/background(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBg) push(\"announcement-bg\", mBg[1]);\n        const mBorder = style.match(/border(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBorder) push(\"announcement-border\", mBorder[1]);\n    });\n    // Utility bar backgrounds\n    $('.utility-bar, [class*=\"utility-bar\" i]').each((_, el)=>{\n        const style = ($(el).attr(\"style\") || \"\").toString();\n        const mBg = style.match(/background(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBg) push(\"utility-bar-bg\", mBg[1]);\n    });\n    // From inline styles of CTA-like elements\n    $('[class*=\"cta\" i], [class*=\"button\" i], [class*=\"btn\" i], [class*=\"add-to-cart\" i]').each((_, el)=>{\n        const style = ($(el).attr(\"style\") || \"\").toString();\n        const mBg = style.match(/background(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBg) push(\"cta-bg\", mBg[1]);\n        const mBorder = style.match(/border(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBorder) push(\"cta-border\", mBorder[1]);\n    });\n    // Explicit <button> elements\n    $(\"button\").each((_, el)=>{\n        const style = ($(el).attr(\"style\") || \"\").toString();\n        const mBg = style.match(/background(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBg) push(\"button-bg\", mBg[1]);\n        const mBorder = style.match(/border(?:-color)?\\s*:\\s*([^;]+)/i);\n        if (mBorder) push(\"button-border\", mBorder[1]);\n    });\n    // Scan style tags for rules targeting announcement/cta classes\n    for (const css of baseCssTexts){\n        // announcement backgrounds\n        const reAnn = /\\.(?:[^\\.{\\s]*?(announcement|anouncement)[^\\s{]*)[^}]*\\{[^}]*?(background(?:-color)?):\\s*([^;}{]+);/ig;\n        let m;\n        while(m = reAnn.exec(css)){\n            push(\"announcement-bg\", m[2]);\n        }\n        // cta backgrounds\n        const reCtaBg = /\\.(?:[^\\.{\\s]*?(cta|button|btn)[^\\s{]*)[^}]*\\{[^}]*?(background(?:-color)?):\\s*([^;}{]+);/ig;\n        while(m = reCtaBg.exec(css)){\n            push(\"cta-bg\", m[2]);\n        }\n        // cta borders\n        const reCtaBorder = /\\.(?:[^\\.{\\s]*?(cta|button|btn)[^\\s{]*)[^}]*\\{[^}]*?(border(?:-color)?):\\s*([^;}{]+);/ig;\n        while(m = reCtaBorder.exec(css)){\n            push(\"cta-border\", m[2]);\n        }\n        // utility bar background\n        const reUtil = /\\.(?:[^\\.\\{\\s]*?(utility-bar)[^\\s{]*)[^}]*\\{[^}]*?(background(?:-color)?):\\s*([^;}{]+);/ig;\n        while(m = reUtil.exec(css)){\n            push(\"utility-bar-bg\", m[2]);\n        }\n        // button tag styles\n        const reButtonTag = /button\\s*\\{[^}]*?(background(?:-color)?):\\s*([^;}{]+);/ig;\n        while(m = reButtonTag.exec(css)){\n            push(\"button-bg\", m[1] || m[2]);\n        }\n    }\n    // Dedupe by color while preserving first occurrence\n    const seen = new Set();\n    return candidates.filter(({ color })=>seen.has(color) ? false : (seen.add(color), true));\n}\n// Extract --atlas-primary-color; fall back to meta theme-color\nfunction extractPrimaryAndText($) {\n    const styles = [];\n    $(\"style\").each((_, el)=>{\n        styles.push($(el).contents().text());\n    });\n    let primary = null;\n    for (const text of styles){\n        const m = text.match(/--atlas-primary-color\\s*:\\s*([^;\\n\\r]+)/i);\n        if (m && m[1]) {\n            primary = normalizeColor(m[1]);\n            if (primary) break;\n        }\n    }\n    const candidates = extractColorCandidates($, styles);\n    // theme-color as a low-priority candidate\n    const theme = $('meta[name=\"theme-color\"]').attr(\"content\");\n    const themeHex = theme ? normalizeColor(theme) : null;\n    if (themeHex) candidates.push({\n        source: \"theme-color\",\n        color: themeHex\n    });\n    // prefer atlas var, else announcement bg, cta bg, cta border, then theme\n    const preferred = primary || candidates[0]?.color || null;\n    // pick text color suggestion\n    let text = \"black\";\n    const hex = preferred || candidates[0]?.color || themeHex;\n    if (hex) {\n        // YIQ formula\n        const r = parseInt(hex.substring(1, 3), 16);\n        const g = parseInt(hex.substring(3, 5), 16);\n        const b = parseInt(hex.substring(5, 7), 16);\n        const yiq = (r * 299 + g * 587 + b * 114) / 1000;\n        text = yiq >= 128 ? \"black\" : \"white\";\n    }\n    return {\n        candidates,\n        primary: preferred || undefined,\n        text\n    };\n}\nfunction extractFonts($) {\n    const set = new Set();\n    $('link[rel=\"stylesheet\"][href*=\"fonts.googleapis.com\"]').each((_, el)=>{\n        const href = $(el).attr(\"href\") || \"\";\n        const url = new URL(href, \"https://example.com\");\n        const fam = url.searchParams.get(\"family\");\n        if (fam) {\n            fam.split(\"|\").forEach((chunk)=>set.add(chunk.split(\":\")[0].replace(/\\+/g, \" \")));\n        }\n    });\n    $(\"style\").each((_, el)=>{\n        const text = $(el).contents().text();\n        const matches = text.match(/font-family\\s*:\\s*([^;\\}]+)/gi) || [];\n        matches.forEach((m)=>{\n            const fam = m.split(\":\")[1]?.trim().replace(/[\"']/g, \"\").split(\",\")[0]?.trim();\n            if (fam) set.add(fam);\n        });\n    });\n    const blocked = new Set([\n        \"sans-serif\",\n        \"serif\",\n        \"monospace\",\n        \"cursive\",\n        \"fantasy\",\n        \"emoji\",\n        \"math\",\n        \"fangsong\",\n        \"system-ui\",\n        \"inherit\",\n        \"initial\",\n        \"unset\"\n    ]);\n    const cleaned = Array.from(set).filter((f)=>f && !/^var\\(/i.test(f) && !/^--/.test(f) && !blocked.has(f.toLowerCase())).slice(0, 5);\n    return cleaned;\n}\nfunction collectImages($, base, type) {\n    const results = [];\n    const regex = type === \"hero\" ? /(main|slideshow|hero|header)/i : /(banner)/i;\n    $(\"img\").each((_, el)=>{\n        const $el = $(el);\n        const cls = ($el.attr(\"class\") || \"\") + \" \" + ($el.parent().attr(\"class\") || \"\");\n        const id = ($el.attr(\"id\") || \"\") + \" \" + ($el.parent().attr(\"id\") || \"\");\n        if (!regex.test(cls + \" \" + id)) return;\n        let src = $el.attr(\"src\") || $el.attr(\"data-src\") || \"\";\n        src = absoluteUrl(base, src);\n        if (!src) return;\n        // width heuristic: attribute width or src hints like _600x\n        const wAttr = parseInt($el.attr(\"width\") || \"0\", 10);\n        const okByAttr = !isNaN(wAttr) && wAttr >= 599;\n        const okBySrc = /[_-](6\\d\\d|[7-9]\\d\\d|\\d{4,})x/i.test(src) || /w(=|%3D)(6\\d\\d|[7-9]\\d\\d|\\d{4,})/i.test(src);\n        if (okByAttr || okBySrc) {\n            results.push(src);\n        }\n    });\n    // Dedupe preserving order\n    return Array.from(new Set(results));\n}\nfunction collectMobileBannerImages($, base) {\n    const results = [];\n    // direct class on img\n    $('img.mobile-banner, img[class*=\"mobile-banner\"]').each((_, el)=>{\n        let src = $(el).attr(\"src\") || $(el).attr(\"data-src\") || \"\";\n        src = absoluteUrl(base, src);\n        if (src) results.push(src);\n    });\n    // nested within elements with class mobile-banner\n    $('.mobile-banner img, [class*=\"mobile-banner\"] img').each((_, el)=>{\n        let src = $(el).attr(\"src\") || $(el).attr(\"data-src\") || \"\";\n        src = absoluteUrl(base, src);\n        if (src) results.push(src);\n    });\n    return Array.from(new Set(results));\n}\nfunction extractStoreName($, baseUrl) {\n    const og = $('meta[property=\"og:site_name\"]').attr(\"content\");\n    if (og) return og;\n    const title = $(\"title\").first().text().trim();\n    if (title) return title;\n    try {\n        const host = new URL(baseUrl).hostname.replace(/^www\\./, \"\");\n        return host.split(\".\")[0];\n    } catch  {\n        return \"\";\n    }\n}\nfunction extractLogo($, base) {\n    // search any element whose class includes 'logo'\n    const logoContainers = $('[class*=\"logo\" i]').toArray();\n    for (const el of logoContainers){\n        const $el = $(el);\n        // inline svg inside\n        const svg = $el.find(\"svg\").first();\n        if (svg && svg.length) {\n            // grab outer HTML\n            const html = $.html(svg);\n            if (html) return {\n                svg: html\n            };\n        }\n        // image tag inside\n        const img = $el.find(\"img\").first();\n        if (img && img.length) {\n            let src = img.attr(\"src\") || img.attr(\"data-src\") || \"\";\n            src = absoluteUrl(base, src);\n            if (src) return {\n                url: src\n            };\n        }\n    }\n    // fallback: simple img with alt/class containing logo\n    const cand = $('img[alt*=\"logo\" i], img[class*=\"logo\" i]').first();\n    const fallback = cand.attr(\"src\") || cand.attr(\"data-src\") || \"\";\n    if (fallback) return {\n        url: absoluteUrl(base, fallback)\n    };\n    // Deep scan: look for header region then pick an <a> linking to root with an <img>\n    try {\n        const origin = new URL(base).origin;\n        // Candidate header containers\n        const headerSelectors = [\n            \"header\",\n            '[class*=\"header\" i]',\n            '[id*=\"header\" i]',\n            \"nav\",\n            '[class*=\"topbar\" i]'\n        ];\n        const $header = $(headerSelectors.join(\",\"));\n        if ($header && $header.length) {\n            // Find image inside anchor linking to root or homepage\n            const anchors = $header.find(\"a[href]\");\n            for (const a of anchors.toArray()){\n                const $a = $(a);\n                const href = ($a.attr(\"href\") || \"\").trim();\n                if (!href) continue;\n                let absHref = href;\n                try {\n                    absHref = new URL(href, origin).toString();\n                } catch  {}\n                if (absHref === origin + \"/\" || absHref === origin) {\n                    const img = $a.find(\"img\").first();\n                    if (img && img.length) {\n                        let src = img.attr(\"src\") || img.attr(\"data-src\") || img.attr(\"data-lazy\") || \"\";\n                        src = absoluteUrl(base, src);\n                        if (src) return {\n                            url: src\n                        };\n                    }\n                    const svg = $a.find(\"svg\").first();\n                    if (svg && svg.length) {\n                        const html = $.html(svg);\n                        if (html) return {\n                            svg: html\n                        };\n                    }\n                }\n            }\n        }\n    } catch  {}\n    // Heuristic: largest image near top of body within first 10 images (often the logo if above fails)\n    try {\n        const imgs = $(\"img\").slice(0, 10).toArray();\n        // Using 'any' for node reference to avoid tight coupling to cheerio internal types across versions\n        let best = null;\n        for (const el of imgs){\n            const $img = $(el);\n            let src = $img.attr(\"src\") || $img.attr(\"data-src\") || \"\";\n            if (!src) continue;\n            src = absoluteUrl(base, src);\n            // Skip tracking pixels / sprites\n            if (/\\.gif$/i.test(src) || /sprite/i.test(src) || /loading|placeholder/i.test(src)) continue;\n            const w = parseInt($img.attr(\"width\") || \"0\", 10);\n            const h = parseInt($img.attr(\"height\") || \"0\", 10);\n            const area = isNaN(w) || isNaN(h) ? 0 : w * h;\n            // Penalize huge banner-like images (very wide and tall)\n            const penalty = w > 800 && h > 300 ? 0.2 : 1;\n            const score = (area || 0) * penalty;\n            if (!best || score > best.score) best = {\n                el,\n                score,\n                src\n            };\n        }\n        if (best && best.src) return {\n            url: best.src\n        };\n    } catch  {}\n    return {};\n}\nasync function handler(req, res) {\n    const { url } = req.query;\n    if (!url || typeof url !== \"string\") {\n        res.status(400).json({\n            error: \"Missing url parameter\"\n        });\n        return;\n    }\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(url, {\n            maxRedirects: 5,\n            headers: {\n                \"User-Agent\": \"Mozilla/5.0\"\n            }\n        });\n        const html = response.data;\n        const $ = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(html);\n        // Remove mega-menu content globally before extraction\n        try {\n            const reMega = /mega[-_ ]?menu/i;\n            const toRemove = $(\"[class]\").filter((_, el)=>reMega.test($(el).attr(\"class\") || \"\")).toArray();\n            if (toRemove.length) $(toRemove).remove();\n        } catch (_) {}\n        const base = new URL(url).toString();\n        const product = await (0,_lib_parser__WEBPACK_IMPORTED_MODULE_2__.parseProduct)(url);\n        const storeName = extractStoreName($, url);\n        const logoObj = extractLogo($, url);\n        const heroImages = collectImages($, base, \"hero\");\n        // Prefer mobile-banner images on current page; then also try homepage and merge/dedupe\n        let bannerImages = collectMobileBannerImages($, base);\n        try {\n            const origin = new URL(base).origin;\n            const homeRes = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(origin, {\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0\"\n                },\n                maxRedirects: 5\n            });\n            const $home = cheerio__WEBPACK_IMPORTED_MODULE_1__.load(homeRes.data);\n            const homeBanners = collectMobileBannerImages($home, origin + \"/\");\n            bannerImages = Array.from(new Set([\n                ...bannerImages,\n                ...homeBanners\n            ]));\n        } catch (_) {\n        // ignore homepage fetch errors\n        }\n        if (bannerImages.length === 0) {\n            bannerImages = collectImages($, base, \"banner\");\n        }\n        const { candidates: colorCandidates, primary: primaryColor, text: textColor } = extractPrimaryAndText($);\n        // Extract announcement copy text if present\n        let announcementCopy = \"\";\n        const ann = $('[class*=\"announcement\" i], [class*=\"anouncement\" i]').first();\n        if (ann && ann.length) {\n            announcementCopy = (ann.text() || \"\").replace(/\\s+/g, \" \").trim();\n        }\n        const fontFamilies = extractFonts($);\n        const payload = {\n            storeName,\n            logo: logoObj.url,\n            logoSvg: logoObj.svg,\n            heroImages,\n            bannerImages,\n            colorScheme: primaryColor ? [\n                primaryColor\n            ] : [],\n            primaryColor,\n            textColor,\n            colorCandidates: colorCandidates,\n            fontFamilies,\n            announcementCopy,\n            product\n        };\n        res.status(200).json(payload);\n    } catch (err) {\n        console.error(\"Analyze error\", err.message || err);\n        res.status(500).json({\n            error: \"Failed to analyze page\"\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBSWdHO21CQUFpQkc7YUFBWTtRQUNyRSxFQUFFLE9BQU9qSCxHQUFHO1FBQ1YsK0JBQStCO1FBQ2pDO1FBQ0EsSUFBSThHLGFBQWF2QyxNQUFNLEtBQUssR0FBRztZQUM3QnVDLGVBQWVqRSxjQUFjckQsR0FBRzlCLE1BQU07UUFDeEM7UUFDQSxNQUFNLEVBQUVnQyxZQUFZd0gsZUFBZSxFQUFFNUYsU0FBUzZGLFlBQVksRUFBRTlGLE1BQU0rRixTQUFTLEVBQUUsR0FBR2xHLHNCQUFzQjFCO1FBQ3RHLDRDQUE0QztRQUM1QyxJQUFJNkgsbUJBQW1CO1FBQ3ZCLE1BQU1DLE1BQU05SCxFQUFFLHVEQUF1RHVFLEtBQUs7UUFDMUUsSUFBSXVELE9BQU9BLElBQUkvQyxNQUFNLEVBQUU7WUFDckI4QyxtQkFBbUIsQ0FBQ0MsSUFBSWpHLElBQUksTUFBTSxFQUFDLEVBQUdsQyxPQUFPLENBQUMsUUFBTyxLQUFLRCxJQUFJO1FBQ2hFO1FBQ0EsTUFBTXFJLGVBQWUxRixhQUFhckM7UUFFbEMsTUFBTWdJLFVBQTJCO1lBQy9CYjtZQUNBYyxNQUFNYixRQUFRakosR0FBRztZQUNqQitKLFNBQVNkLFFBQVF2QyxHQUFHO1lBQ3BCd0M7WUFDQUM7WUFDQWEsYUFBYVIsZUFBZTtnQkFBQ0E7YUFBYSxHQUFHLEVBQUU7WUFDL0NBO1lBQ0FDO1lBQ0FGLGlCQUFpQkE7WUFDakJLO1lBQ0FGO1lBQ0FYO1FBQ0Y7UUFDQWIsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQ3dCO0lBQ3ZCLEVBQUUsT0FBT0ksS0FBVTtRQUNqQkMsUUFBUTVCLEtBQUssQ0FBQyxpQkFBaUIyQixJQUFJRSxPQUFPLElBQUlGO1FBQzlDL0IsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXlCO0lBQ3pEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZG0tYnVpbGRlci8uL3BhZ2VzL2FwaS9hbmFseXplLnRzPzhiMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0ICogYXMgY2hlZXJpbyBmcm9tICdjaGVlcmlvJztcbmltcG9ydCB7IHBhcnNlUHJvZHVjdCB9IGZyb20gJy4uLy4uL2xpYi9wYXJzZXInO1xuXG50eXBlIEFuYWx5emVSZXNwb25zZSA9IHtcbiAgc3RvcmVOYW1lOiBzdHJpbmc7XG4gIGxvZ28/OiBzdHJpbmc7IC8vIGltYWdlIFVSTCBpZiBhdmFpbGFibGVcbiAgbG9nb1N2Zz86IHN0cmluZzsgLy8gaW5saW5lIFNWRyBtYXJrdXAgaWYgYXZhaWxhYmxlXG4gIGhlcm9JbWFnZXM6IHN0cmluZ1tdO1xuICBiYW5uZXJJbWFnZXM6IHN0cmluZ1tdO1xuICAvLyBEZXByZWNhdGVkOiB1c2UgcHJpbWFyeUNvbG9yL3RleHRDb2xvcjsga2VlcCBmb3IgYmFja3dhcmQgY29tcGF0XG4gIGNvbG9yU2NoZW1lPzogc3RyaW5nW107IC8vIFtwcmltYXJ5XVxuICBwcmltYXJ5Q29sb3I/OiBzdHJpbmc7XG4gIHRleHRDb2xvcj86ICdibGFjaycgfCAnd2hpdGUnO1xuICBjb2xvckNhbmRpZGF0ZXM/OiB7IHNvdXJjZTogc3RyaW5nOyBjb2xvcjogc3RyaW5nIH1bXTtcbiAgZm9udEZhbWlsaWVzOiBzdHJpbmdbXTtcbiAgYW5ub3VuY2VtZW50Q29weT86IHN0cmluZztcbiAgcHJvZHVjdDogYW55OyAvLyByZXVzZSBQcm9kdWN0RGF0YSBzaGFwZSBmcm9tIGxpYi90eXBlcyBvbiBjbGllbnRcbn07XG5cbmZ1bmN0aW9uIGFic29sdXRlVXJsKGJhc2U6IHN0cmluZywgdXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIXVybCkgcmV0dXJuICcnO1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgcmV0dXJuIHVybDtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCcvLycpKSByZXR1cm4gJ2h0dHBzOicgKyB1cmw7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpKSByZXR1cm4gbmV3IFVSTChiYXNlKS5vcmlnaW4gKyB1cmw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodXJsLCBiYXNlKS50b1N0cmluZygpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJnYlRvSGV4KGlucHV0OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgLy8gc3VwcG9ydHMgcmdiKGEpIGxpa2UgcmdiKDI1NSwwLDApIG9yIHJnYmEoMjU1LDAsMCwxKVxuICBjb25zdCBtID0gaW5wdXQubWF0Y2goL3JnYmE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KS9pKTtcbiAgaWYgKCFtKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcGFyc2VJbnQobVsxXSwgMTApKSk7XG4gIGNvbnN0IGcgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHBhcnNlSW50KG1bMl0sIDEwKSkpO1xuICBjb25zdCBiID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBwYXJzZUludChtWzNdLCAxMCkpKTtcbiAgY29uc3QgdG9IZXggPSAobjogbnVtYmVyKSA9PiBuLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBgIyR7dG9IZXgocil9JHt0b0hleChnKX0ke3RvSGV4KGIpfWA7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKHZhbDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghdmFsKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2xlYW5lZCA9IHZhbC50cmltKCkucmVwbGFjZSgvIWltcG9ydGFudC9pLCAnJykudHJpbSgpO1xuICBpZiAoL152YXJcXCgvaS50ZXN0KGNsZWFuZWQpKSByZXR1cm4gbnVsbDtcbiAgaWYgKC9edHJhbnNwYXJlbnQkL2kudGVzdChjbGVhbmVkKSkgcmV0dXJuIG51bGw7XG4gIGlmICgvXmN1cnJlbnRDb2xvciQvaS50ZXN0KGNsZWFuZWQpKSByZXR1cm4gbnVsbDtcbiAgLy8gaGV4XG4gIGNvbnN0IGhleCA9IGNsZWFuZWQubWF0Y2goL14jKFswLTlhLWZdezN9fFswLTlhLWZdezZ9KSQvaSk/LlswXTtcbiAgaWYgKGhleCkgcmV0dXJuIGhleC50b1VwcGVyQ2FzZSgpO1xuICAvLyByZ2IvcmdiYVxuICBjb25zdCBhc0hleCA9IHJnYlRvSGV4KGNsZWFuZWQpO1xuICBpZiAoYXNIZXgpIHJldHVybiBhc0hleDtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEV4dHJhY3QgY29sb3IgY2FuZGlkYXRlcyBmcm9tIENTUyBhbmQgaW5saW5lIHN0eWxlcyBmb3IgYW5ub3VuY2VtZW50IGJhcnMgYW5kIENUQXNcbmZ1bmN0aW9uIGV4dHJhY3RDb2xvckNhbmRpZGF0ZXMoJDogY2hlZXJpby5DaGVlcmlvQVBJLCBiYXNlQ3NzVGV4dHM6IHN0cmluZ1tdKTogeyBzb3VyY2U6IHN0cmluZzsgY29sb3I6IHN0cmluZyB9W10ge1xuICBjb25zdCBjYW5kaWRhdGVzOiB7IHNvdXJjZTogc3RyaW5nOyBjb2xvcjogc3RyaW5nIH1bXSA9IFtdO1xuICBjb25zdCBwdXNoID0gKHNvdXJjZTogc3RyaW5nLCBjb2xvcj86IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICBjb25zdCBjID0gY29sb3IgJiYgbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICAgIGlmICghYykgcmV0dXJuO1xuICAgIGNhbmRpZGF0ZXMucHVzaCh7IHNvdXJjZSwgY29sb3I6IGMgfSk7XG4gIH07XG4gIC8vIEZyb20gaW5saW5lIHN0eWxlcyBvZiBhbm5vdW5jZW1lbnQgZWxlbWVudHNcbiAgJCgnW2NsYXNzKj1cImFubm91bmNlbWVudFwiIGldLCBbY2xhc3MqPVwiYW5vdW5jZW1lbnRcIiBpXScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSAoJChlbCkuYXR0cignc3R5bGUnKSB8fCAnJykudG9TdHJpbmcoKTtcbiAgICBjb25zdCBtQmcgPSBzdHlsZS5tYXRjaCgvYmFja2dyb3VuZCg/Oi1jb2xvcik/XFxzKjpcXHMqKFteO10rKS9pKTtcbiAgICBpZiAobUJnKSBwdXNoKCdhbm5vdW5jZW1lbnQtYmcnLCBtQmdbMV0pO1xuICAgIGNvbnN0IG1Cb3JkZXIgPSBzdHlsZS5tYXRjaCgvYm9yZGVyKD86LWNvbG9yKT9cXHMqOlxccyooW147XSspL2kpO1xuICAgIGlmIChtQm9yZGVyKSBwdXNoKCdhbm5vdW5jZW1lbnQtYm9yZGVyJywgbUJvcmRlclsxXSk7XG4gIH0pO1xuICAvLyBVdGlsaXR5IGJhciBiYWNrZ3JvdW5kc1xuICAkKCcudXRpbGl0eS1iYXIsIFtjbGFzcyo9XCJ1dGlsaXR5LWJhclwiIGldJykuZWFjaCgoXywgZWwpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9ICgkKGVsKS5hdHRyKCdzdHlsZScpIHx8ICcnKS50b1N0cmluZygpO1xuICAgIGNvbnN0IG1CZyA9IHN0eWxlLm1hdGNoKC9iYWNrZ3JvdW5kKD86LWNvbG9yKT9cXHMqOlxccyooW147XSspL2kpO1xuICAgIGlmIChtQmcpIHB1c2goJ3V0aWxpdHktYmFyLWJnJywgbUJnWzFdKTtcbiAgfSk7XG4gIC8vIEZyb20gaW5saW5lIHN0eWxlcyBvZiBDVEEtbGlrZSBlbGVtZW50c1xuICAkKCdbY2xhc3MqPVwiY3RhXCIgaV0sIFtjbGFzcyo9XCJidXR0b25cIiBpXSwgW2NsYXNzKj1cImJ0blwiIGldLCBbY2xhc3MqPVwiYWRkLXRvLWNhcnRcIiBpXScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSAoJChlbCkuYXR0cignc3R5bGUnKSB8fCAnJykudG9TdHJpbmcoKTtcbiAgICBjb25zdCBtQmcgPSBzdHlsZS5tYXRjaCgvYmFja2dyb3VuZCg/Oi1jb2xvcik/XFxzKjpcXHMqKFteO10rKS9pKTtcbiAgICBpZiAobUJnKSBwdXNoKCdjdGEtYmcnLCBtQmdbMV0pO1xuICAgIGNvbnN0IG1Cb3JkZXIgPSBzdHlsZS5tYXRjaCgvYm9yZGVyKD86LWNvbG9yKT9cXHMqOlxccyooW147XSspL2kpO1xuICAgIGlmIChtQm9yZGVyKSBwdXNoKCdjdGEtYm9yZGVyJywgbUJvcmRlclsxXSk7XG4gIH0pO1xuICAvLyBFeHBsaWNpdCA8YnV0dG9uPiBlbGVtZW50c1xuICAkKCdidXR0b24nKS5lYWNoKChfLCBlbCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gKCQoZWwpLmF0dHIoJ3N0eWxlJykgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbUJnID0gc3R5bGUubWF0Y2goL2JhY2tncm91bmQoPzotY29sb3IpP1xccyo6XFxzKihbXjtdKykvaSk7XG4gICAgaWYgKG1CZykgcHVzaCgnYnV0dG9uLWJnJywgbUJnWzFdKTtcbiAgICBjb25zdCBtQm9yZGVyID0gc3R5bGUubWF0Y2goL2JvcmRlcig/Oi1jb2xvcik/XFxzKjpcXHMqKFteO10rKS9pKTtcbiAgICBpZiAobUJvcmRlcikgcHVzaCgnYnV0dG9uLWJvcmRlcicsIG1Cb3JkZXJbMV0pO1xuICB9KTtcbiAgLy8gU2NhbiBzdHlsZSB0YWdzIGZvciBydWxlcyB0YXJnZXRpbmcgYW5ub3VuY2VtZW50L2N0YSBjbGFzc2VzXG4gIGZvciAoY29uc3QgY3NzIG9mIGJhc2VDc3NUZXh0cykge1xuICAgIC8vIGFubm91bmNlbWVudCBiYWNrZ3JvdW5kc1xuICAgIGNvbnN0IHJlQW5uID0gL1xcLig/OlteXFwue1xcc10qPyhhbm5vdW5jZW1lbnR8YW5vdW5jZW1lbnQpW15cXHN7XSopW159XSpcXHtbXn1dKj8oYmFja2dyb3VuZCg/Oi1jb2xvcik/KTpcXHMqKFteO317XSspOy9pZztcbiAgICBsZXQgbTogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcbiAgICB3aGlsZSAoKG0gPSByZUFubi5leGVjKGNzcykpKSB7XG4gICAgICBwdXNoKCdhbm5vdW5jZW1lbnQtYmcnLCBtWzJdKTtcbiAgICB9XG4gICAgLy8gY3RhIGJhY2tncm91bmRzXG4gICAgY29uc3QgcmVDdGFCZyA9IC9cXC4oPzpbXlxcLntcXHNdKj8oY3RhfGJ1dHRvbnxidG4pW15cXHN7XSopW159XSpcXHtbXn1dKj8oYmFja2dyb3VuZCg/Oi1jb2xvcik/KTpcXHMqKFteO317XSspOy9pZztcbiAgICB3aGlsZSAoKG0gPSByZUN0YUJnLmV4ZWMoY3NzKSkpIHtcbiAgICAgIHB1c2goJ2N0YS1iZycsIG1bMl0pO1xuICAgIH1cbiAgICAvLyBjdGEgYm9yZGVyc1xuICAgIGNvbnN0IHJlQ3RhQm9yZGVyID0gL1xcLig/OlteXFwue1xcc10qPyhjdGF8YnV0dG9ufGJ0bilbXlxcc3tdKilbXn1dKlxce1tefV0qPyhib3JkZXIoPzotY29sb3IpPyk6XFxzKihbXjt9e10rKTsvaWc7XG4gICAgd2hpbGUgKChtID0gcmVDdGFCb3JkZXIuZXhlYyhjc3MpKSkge1xuICAgICAgcHVzaCgnY3RhLWJvcmRlcicsIG1bMl0pO1xuICAgIH1cbiAgICAvLyB1dGlsaXR5IGJhciBiYWNrZ3JvdW5kXG4gICAgY29uc3QgcmVVdGlsID0gL1xcLig/OlteXFwuXFx7XFxzXSo/KHV0aWxpdHktYmFyKVteXFxze10qKVtefV0qXFx7W159XSo/KGJhY2tncm91bmQoPzotY29sb3IpPyk6XFxzKihbXjt9e10rKTsvaWc7XG4gICAgd2hpbGUgKChtID0gcmVVdGlsLmV4ZWMoY3NzKSkpIHtcbiAgICAgIHB1c2goJ3V0aWxpdHktYmFyLWJnJywgbVsyXSk7XG4gICAgfVxuICAgIC8vIGJ1dHRvbiB0YWcgc3R5bGVzXG4gICAgY29uc3QgcmVCdXR0b25UYWcgPSAvYnV0dG9uXFxzKlxce1tefV0qPyhiYWNrZ3JvdW5kKD86LWNvbG9yKT8pOlxccyooW147fXtdKyk7L2lnO1xuICAgIHdoaWxlICgobSA9IHJlQnV0dG9uVGFnLmV4ZWMoY3NzKSkpIHtcbiAgICAgIHB1c2goJ2J1dHRvbi1iZycsIG1bMV0gfHwgbVsyXSk7XG4gICAgfVxuICB9XG4gIC8vIERlZHVwZSBieSBjb2xvciB3aGlsZSBwcmVzZXJ2aW5nIGZpcnN0IG9jY3VycmVuY2VcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICByZXR1cm4gY2FuZGlkYXRlcy5maWx0ZXIoKHsgY29sb3IgfSkgPT4gKHNlZW4uaGFzKGNvbG9yKSA/IGZhbHNlIDogKHNlZW4uYWRkKGNvbG9yKSwgdHJ1ZSkpKTtcbn1cblxuLy8gRXh0cmFjdCAtLWF0bGFzLXByaW1hcnktY29sb3I7IGZhbGwgYmFjayB0byBtZXRhIHRoZW1lLWNvbG9yXG5mdW5jdGlvbiBleHRyYWN0UHJpbWFyeUFuZFRleHQoJDogY2hlZXJpby5DaGVlcmlvQVBJKTogeyBjYW5kaWRhdGVzOiB7IHNvdXJjZTogc3RyaW5nOyBjb2xvcjogc3RyaW5nIH1bXTsgcHJpbWFyeT86IHN0cmluZzsgdGV4dD86ICdibGFjaycgfCAnd2hpdGUnIH0ge1xuICBjb25zdCBzdHlsZXM6IHN0cmluZ1tdID0gW107XG4gICQoJ3N0eWxlJykuZWFjaCgoXywgZWwpID0+IHtcbiAgICBzdHlsZXMucHVzaCgkKGVsKS5jb250ZW50cygpLnRleHQoKSk7XG4gIH0pO1xuICBsZXQgcHJpbWFyeTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIGZvciAoY29uc3QgdGV4dCBvZiBzdHlsZXMpIHtcbiAgICBjb25zdCBtID0gdGV4dC5tYXRjaCgvLS1hdGxhcy1wcmltYXJ5LWNvbG9yXFxzKjpcXHMqKFteO1xcblxccl0rKS9pKTtcbiAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICBwcmltYXJ5ID0gbm9ybWFsaXplQ29sb3IobVsxXSk7XG4gICAgICBpZiAocHJpbWFyeSkgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBleHRyYWN0Q29sb3JDYW5kaWRhdGVzKCQsIHN0eWxlcyk7XG4gIC8vIHRoZW1lLWNvbG9yIGFzIGEgbG93LXByaW9yaXR5IGNhbmRpZGF0ZVxuICBjb25zdCB0aGVtZSA9ICQoJ21ldGFbbmFtZT1cInRoZW1lLWNvbG9yXCJdJykuYXR0cignY29udGVudCcpO1xuICBjb25zdCB0aGVtZUhleCA9IHRoZW1lID8gbm9ybWFsaXplQ29sb3IodGhlbWUpIDogbnVsbDtcbiAgaWYgKHRoZW1lSGV4KSBjYW5kaWRhdGVzLnB1c2goeyBzb3VyY2U6ICd0aGVtZS1jb2xvcicsIGNvbG9yOiB0aGVtZUhleCB9KTtcbiAgLy8gcHJlZmVyIGF0bGFzIHZhciwgZWxzZSBhbm5vdW5jZW1lbnQgYmcsIGN0YSBiZywgY3RhIGJvcmRlciwgdGhlbiB0aGVtZVxuICBjb25zdCBwcmVmZXJyZWQgPSBwcmltYXJ5IHx8IChjYW5kaWRhdGVzWzBdPy5jb2xvciB8fCBudWxsKTtcbiAgLy8gcGljayB0ZXh0IGNvbG9yIHN1Z2dlc3Rpb25cbiAgbGV0IHRleHQ6ICdibGFjaycgfCAnd2hpdGUnID0gJ2JsYWNrJztcbiAgY29uc3QgaGV4ID0gcHJlZmVycmVkIHx8IGNhbmRpZGF0ZXNbMF0/LmNvbG9yIHx8IHRoZW1lSGV4O1xuICBpZiAoaGV4KSB7XG4gICAgLy8gWUlRIGZvcm11bGFcbiAgICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygxLCAzKSwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNSwgNyksIDE2KTtcbiAgICBjb25zdCB5aXEgPSAociAqIDI5OSArIGcgKiA1ODcgKyBiICogMTE0KSAvIDEwMDA7XG4gICAgdGV4dCA9IHlpcSA+PSAxMjggPyAnYmxhY2snIDogJ3doaXRlJztcbiAgfVxuICByZXR1cm4geyBjYW5kaWRhdGVzLCBwcmltYXJ5OiBwcmVmZXJyZWQgfHwgdW5kZWZpbmVkLCB0ZXh0IH07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RGb250cygkOiBjaGVlcmlvLkNoZWVyaW9BUEkpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAkKCdsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl1baHJlZio9XCJmb250cy5nb29nbGVhcGlzLmNvbVwiXScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgY29uc3QgaHJlZiA9ICQoZWwpLmF0dHIoJ2hyZWYnKSB8fCAnJztcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYsICdodHRwczovL2V4YW1wbGUuY29tJyk7XG4gICAgY29uc3QgZmFtID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2ZhbWlseScpO1xuICAgIGlmIChmYW0pIHtcbiAgICAgIGZhbS5zcGxpdCgnfCcpLmZvckVhY2goKGNodW5rKSA9PiBzZXQuYWRkKGNodW5rLnNwbGl0KCc6JylbMF0ucmVwbGFjZSgvXFwrL2csICcgJykpKTtcbiAgICB9XG4gIH0pO1xuICAkKCdzdHlsZScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgY29uc3QgdGV4dCA9ICQoZWwpLmNvbnRlbnRzKCkudGV4dCgpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKC9mb250LWZhbWlseVxccyo6XFxzKihbXjtcXH1dKykvZ2kpIHx8IFtdO1xuICAgIG1hdGNoZXMuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgY29uc3QgZmFtID0gbS5zcGxpdCgnOicpWzFdPy50cmltKCkucmVwbGFjZSgvW1wiJ10vZywgJycpLnNwbGl0KCcsJylbMF0/LnRyaW0oKTtcbiAgICAgIGlmIChmYW0pIHNldC5hZGQoZmFtKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGJsb2NrZWQgPSBuZXcgU2V0KFsnc2Fucy1zZXJpZicsJ3NlcmlmJywnbW9ub3NwYWNlJywnY3Vyc2l2ZScsJ2ZhbnRhc3knLCdlbW9qaScsJ21hdGgnLCdmYW5nc29uZycsJ3N5c3RlbS11aScsJ2luaGVyaXQnLCdpbml0aWFsJywndW5zZXQnXSk7XG4gIGNvbnN0IGNsZWFuZWQgPSBBcnJheS5mcm9tKHNldClcbiAgICAuZmlsdGVyKGYgPT4gZiAmJiAhL152YXJcXCgvaS50ZXN0KGYpICYmICEvXi0tLy50ZXN0KGYpICYmICFibG9ja2VkLmhhcyhmLnRvTG93ZXJDYXNlKCkpKVxuICAgIC5zbGljZSgwLCA1KTtcbiAgcmV0dXJuIGNsZWFuZWQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RJbWFnZXMoJDogY2hlZXJpby5DaGVlcmlvQVBJLCBiYXNlOiBzdHJpbmcsIHR5cGU6ICdoZXJvJyB8ICdiYW5uZXInKTogc3RyaW5nW10ge1xuICBjb25zdCByZXN1bHRzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCByZWdleCA9IHR5cGUgPT09ICdoZXJvJyA/IC8obWFpbnxzbGlkZXNob3d8aGVyb3xoZWFkZXIpL2kgOiAvKGJhbm5lcikvaTtcbiAgJCgnaW1nJykuZWFjaCgoXywgZWwpID0+IHtcbiAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICBjb25zdCBjbHMgPSAoJGVsLmF0dHIoJ2NsYXNzJykgfHwgJycpICsgJyAnICsgKCRlbC5wYXJlbnQoKS5hdHRyKCdjbGFzcycpIHx8ICcnKTtcbiAgICBjb25zdCBpZCA9ICgkZWwuYXR0cignaWQnKSB8fCAnJykgKyAnICcgKyAoJGVsLnBhcmVudCgpLmF0dHIoJ2lkJykgfHwgJycpO1xuICAgIGlmICghcmVnZXgudGVzdChjbHMgKyAnICcgKyBpZCkpIHJldHVybjtcbiAgICBsZXQgc3JjID0gJGVsLmF0dHIoJ3NyYycpIHx8ICRlbC5hdHRyKCdkYXRhLXNyYycpIHx8ICcnO1xuICAgIHNyYyA9IGFic29sdXRlVXJsKGJhc2UsIHNyYyk7XG4gICAgaWYgKCFzcmMpIHJldHVybjtcbiAgICAvLyB3aWR0aCBoZXVyaXN0aWM6IGF0dHJpYnV0ZSB3aWR0aCBvciBzcmMgaGludHMgbGlrZSBfNjAweFxuICAgIGNvbnN0IHdBdHRyID0gcGFyc2VJbnQoJGVsLmF0dHIoJ3dpZHRoJykgfHwgJzAnLCAxMCk7XG4gICAgY29uc3Qgb2tCeUF0dHIgPSAhaXNOYU4od0F0dHIpICYmIHdBdHRyID49IDU5OTtcbiAgICBjb25zdCBva0J5U3JjID0gL1tfLV0oNlxcZFxcZHxbNy05XVxcZFxcZHxcXGR7NCx9KXgvaS50ZXN0KHNyYykgfHwgL3coPXwlM0QpKDZcXGRcXGR8WzctOV1cXGRcXGR8XFxkezQsfSkvaS50ZXN0KHNyYyk7XG4gICAgaWYgKG9rQnlBdHRyIHx8IG9rQnlTcmMpIHtcbiAgICAgIHJlc3VsdHMucHVzaChzcmMpO1xuICAgIH1cbiAgfSk7XG4gIC8vIERlZHVwZSBwcmVzZXJ2aW5nIG9yZGVyXG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQocmVzdWx0cykpO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0TW9iaWxlQmFubmVySW1hZ2VzKCQ6IGNoZWVyaW8uQ2hlZXJpb0FQSSwgYmFzZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCByZXN1bHRzOiBzdHJpbmdbXSA9IFtdO1xuICAvLyBkaXJlY3QgY2xhc3Mgb24gaW1nXG4gICQoJ2ltZy5tb2JpbGUtYmFubmVyLCBpbWdbY2xhc3MqPVwibW9iaWxlLWJhbm5lclwiXScpLmVhY2goKF8sIGVsKSA9PiB7XG4gICAgbGV0IHNyYyA9ICQoZWwpLmF0dHIoJ3NyYycpIHx8ICQoZWwpLmF0dHIoJ2RhdGEtc3JjJykgfHwgJyc7XG4gICAgc3JjID0gYWJzb2x1dGVVcmwoYmFzZSwgc3JjKTtcbiAgICBpZiAoc3JjKSByZXN1bHRzLnB1c2goc3JjKTtcbiAgfSk7XG4gIC8vIG5lc3RlZCB3aXRoaW4gZWxlbWVudHMgd2l0aCBjbGFzcyBtb2JpbGUtYmFubmVyXG4gICQoJy5tb2JpbGUtYmFubmVyIGltZywgW2NsYXNzKj1cIm1vYmlsZS1iYW5uZXJcIl0gaW1nJykuZWFjaCgoXywgZWwpID0+IHtcbiAgICBsZXQgc3JjID0gJChlbCkuYXR0cignc3JjJykgfHwgJChlbCkuYXR0cignZGF0YS1zcmMnKSB8fCAnJztcbiAgICBzcmMgPSBhYnNvbHV0ZVVybChiYXNlLCBzcmMpO1xuICAgIGlmIChzcmMpIHJlc3VsdHMucHVzaChzcmMpO1xuICB9KTtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyZXN1bHRzKSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RTdG9yZU5hbWUoJDogY2hlZXJpby5DaGVlcmlvQVBJLCBiYXNlVXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBvZyA9ICQoJ21ldGFbcHJvcGVydHk9XCJvZzpzaXRlX25hbWVcIl0nKS5hdHRyKCdjb250ZW50Jyk7XG4gIGlmIChvZykgcmV0dXJuIG9nO1xuICBjb25zdCB0aXRsZSA9ICQoJ3RpdGxlJykuZmlyc3QoKS50ZXh0KCkudHJpbSgpO1xuICBpZiAodGl0bGUpIHJldHVybiB0aXRsZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBob3N0ID0gbmV3IFVSTChiYXNlVXJsKS5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuICAgIHJldHVybiBob3N0LnNwbGl0KCcuJylbMF07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TG9nbygkOiBjaGVlcmlvLkNoZWVyaW9BUEksIGJhc2U6IHN0cmluZyk6IHsgdXJsPzogc3RyaW5nOyBzdmc/OiBzdHJpbmcgfSB7XG4gIC8vIHNlYXJjaCBhbnkgZWxlbWVudCB3aG9zZSBjbGFzcyBpbmNsdWRlcyAnbG9nbydcbiAgY29uc3QgbG9nb0NvbnRhaW5lcnMgPSAkKCdbY2xhc3MqPVwibG9nb1wiIGldJykudG9BcnJheSgpO1xuICBmb3IgKGNvbnN0IGVsIG9mIGxvZ29Db250YWluZXJzKSB7XG4gICAgY29uc3QgJGVsID0gJChlbCBhcyBhbnkpO1xuICAgIC8vIGlubGluZSBzdmcgaW5zaWRlXG4gICAgY29uc3Qgc3ZnID0gJGVsLmZpbmQoJ3N2ZycpLmZpcnN0KCk7XG4gICAgaWYgKHN2ZyAmJiBzdmcubGVuZ3RoKSB7XG4gICAgICAvLyBncmFiIG91dGVyIEhUTUxcbiAgICAgIGNvbnN0IGh0bWwgPSAkLmh0bWwoc3ZnKTtcbiAgICAgIGlmIChodG1sKSByZXR1cm4geyBzdmc6IGh0bWwgfTtcbiAgICB9XG4gICAgLy8gaW1hZ2UgdGFnIGluc2lkZVxuICAgIGNvbnN0IGltZyA9ICRlbC5maW5kKCdpbWcnKS5maXJzdCgpO1xuICAgIGlmIChpbWcgJiYgaW1nLmxlbmd0aCkge1xuICAgICAgbGV0IHNyYyA9IGltZy5hdHRyKCdzcmMnKSB8fCBpbWcuYXR0cignZGF0YS1zcmMnKSB8fCAnJztcbiAgICAgIHNyYyA9IGFic29sdXRlVXJsKGJhc2UsIHNyYyk7XG4gICAgICBpZiAoc3JjKSByZXR1cm4geyB1cmw6IHNyYyB9O1xuICAgIH1cbiAgfVxuICAvLyBmYWxsYmFjazogc2ltcGxlIGltZyB3aXRoIGFsdC9jbGFzcyBjb250YWluaW5nIGxvZ29cbiAgY29uc3QgY2FuZCA9ICQoJ2ltZ1thbHQqPVwibG9nb1wiIGldLCBpbWdbY2xhc3MqPVwibG9nb1wiIGldJykuZmlyc3QoKTtcbiAgY29uc3QgZmFsbGJhY2sgPSBjYW5kLmF0dHIoJ3NyYycpIHx8IGNhbmQuYXR0cignZGF0YS1zcmMnKSB8fCAnJztcbiAgaWYgKGZhbGxiYWNrKSByZXR1cm4geyB1cmw6IGFic29sdXRlVXJsKGJhc2UsIGZhbGxiYWNrKSB9O1xuXG4gIC8vIERlZXAgc2NhbjogbG9vayBmb3IgaGVhZGVyIHJlZ2lvbiB0aGVuIHBpY2sgYW4gPGE+IGxpbmtpbmcgdG8gcm9vdCB3aXRoIGFuIDxpbWc+XG4gIHRyeSB7XG4gICAgY29uc3Qgb3JpZ2luID0gbmV3IFVSTChiYXNlKS5vcmlnaW47XG4gICAgLy8gQ2FuZGlkYXRlIGhlYWRlciBjb250YWluZXJzXG4gICAgY29uc3QgaGVhZGVyU2VsZWN0b3JzID0gWydoZWFkZXInLCAnW2NsYXNzKj1cImhlYWRlclwiIGldJywgJ1tpZCo9XCJoZWFkZXJcIiBpXScsICduYXYnLCAnW2NsYXNzKj1cInRvcGJhclwiIGldJ107XG4gICAgY29uc3QgJGhlYWRlciA9ICQoaGVhZGVyU2VsZWN0b3JzLmpvaW4oJywnKSk7XG4gICAgaWYgKCRoZWFkZXIgJiYgJGhlYWRlci5sZW5ndGgpIHtcbiAgICAgIC8vIEZpbmQgaW1hZ2UgaW5zaWRlIGFuY2hvciBsaW5raW5nIHRvIHJvb3Qgb3IgaG9tZXBhZ2VcbiAgICAgIGNvbnN0IGFuY2hvcnMgPSAkaGVhZGVyLmZpbmQoJ2FbaHJlZl0nKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhbmNob3JzLnRvQXJyYXkoKSkge1xuICAgICAgICBjb25zdCAkYSA9ICQoYSk7XG4gICAgICAgIGNvbnN0IGhyZWYgPSAoJGEuYXR0cignaHJlZicpIHx8ICcnKS50cmltKCk7XG4gICAgICAgIGlmICghaHJlZikgY29udGludWU7XG4gICAgICAgIGxldCBhYnNIcmVmID0gaHJlZjtcbiAgICAgICAgdHJ5IHsgYWJzSHJlZiA9IG5ldyBVUkwoaHJlZiwgb3JpZ2luKS50b1N0cmluZygpOyB9IGNhdGNoIHt9XG4gICAgICAgIGlmIChhYnNIcmVmID09PSBvcmlnaW4gKyAnLycgfHwgYWJzSHJlZiA9PT0gb3JpZ2luKSB7XG4gICAgICAgICAgY29uc3QgaW1nID0gJGEuZmluZCgnaW1nJykuZmlyc3QoKTtcbiAgICAgICAgICBpZiAoaW1nICYmIGltZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBzcmMgPSBpbWcuYXR0cignc3JjJykgfHwgaW1nLmF0dHIoJ2RhdGEtc3JjJykgfHwgaW1nLmF0dHIoJ2RhdGEtbGF6eScpIHx8ICcnO1xuICAgICAgICAgICAgc3JjID0gYWJzb2x1dGVVcmwoYmFzZSwgc3JjKTtcbiAgICAgICAgICAgIGlmIChzcmMpIHJldHVybiB7IHVybDogc3JjIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN2ZyA9ICRhLmZpbmQoJ3N2ZycpLmZpcnN0KCk7XG4gICAgICAgICAgaWYgKHN2ZyAmJiBzdmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJC5odG1sKHN2Zyk7XG4gICAgICAgICAgICBpZiAoaHRtbCkgcmV0dXJuIHsgc3ZnOiBodG1sIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHt9XG5cbiAgLy8gSGV1cmlzdGljOiBsYXJnZXN0IGltYWdlIG5lYXIgdG9wIG9mIGJvZHkgd2l0aGluIGZpcnN0IDEwIGltYWdlcyAob2Z0ZW4gdGhlIGxvZ28gaWYgYWJvdmUgZmFpbHMpXG4gIHRyeSB7XG4gICAgY29uc3QgaW1ncyA9ICQoJ2ltZycpLnNsaWNlKDAsIDEwKS50b0FycmF5KCk7XG4gIC8vIFVzaW5nICdhbnknIGZvciBub2RlIHJlZmVyZW5jZSB0byBhdm9pZCB0aWdodCBjb3VwbGluZyB0byBjaGVlcmlvIGludGVybmFsIHR5cGVzIGFjcm9zcyB2ZXJzaW9uc1xuICBsZXQgYmVzdDogeyBlbDogYW55OyBzY29yZTogbnVtYmVyOyBzcmM6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBlbCBvZiBpbWdzKSB7XG4gICAgICBjb25zdCAkaW1nID0gJChlbCBhcyBhbnkpO1xuICAgICAgbGV0IHNyYyA9ICRpbWcuYXR0cignc3JjJykgfHwgJGltZy5hdHRyKCdkYXRhLXNyYycpIHx8ICcnO1xuICAgICAgaWYgKCFzcmMpIGNvbnRpbnVlO1xuICAgICAgc3JjID0gYWJzb2x1dGVVcmwoYmFzZSwgc3JjKTtcbiAgICAgIC8vIFNraXAgdHJhY2tpbmcgcGl4ZWxzIC8gc3ByaXRlc1xuICAgICAgaWYgKC9cXC5naWYkL2kudGVzdChzcmMpIHx8IC9zcHJpdGUvaS50ZXN0KHNyYykgfHwgL2xvYWRpbmd8cGxhY2Vob2xkZXIvaS50ZXN0KHNyYykpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdyA9IHBhcnNlSW50KCRpbWcuYXR0cignd2lkdGgnKSB8fCAnMCcsIDEwKTtcbiAgICAgIGNvbnN0IGggPSBwYXJzZUludCgkaW1nLmF0dHIoJ2hlaWdodCcpIHx8ICcwJywgMTApO1xuICAgICAgY29uc3QgYXJlYSA9IChpc05hTih3KSB8fCBpc05hTihoKSA/IDAgOiB3ICogaCk7XG4gICAgICAvLyBQZW5hbGl6ZSBodWdlIGJhbm5lci1saWtlIGltYWdlcyAodmVyeSB3aWRlIGFuZCB0YWxsKVxuICAgICAgY29uc3QgcGVuYWx0eSA9ICh3ID4gODAwICYmIGggPiAzMDApID8gMC4yIDogMTtcbiAgICAgIGNvbnN0IHNjb3JlID0gKGFyZWEgfHwgMCkgKiBwZW5hbHR5O1xuICAgICAgaWYgKCFiZXN0IHx8IHNjb3JlID4gYmVzdC5zY29yZSkgYmVzdCA9IHsgZWwsIHNjb3JlLCBzcmMgfTtcbiAgICB9XG4gICAgaWYgKGJlc3QgJiYgYmVzdC5zcmMpIHJldHVybiB7IHVybDogYmVzdC5zcmMgfTtcbiAgfSBjYXRjaCB7fVxuICByZXR1cm4ge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpIHtcbiAgY29uc3QgeyB1cmwgfSA9IHJlcS5xdWVyeTtcbiAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnTWlzc2luZyB1cmwgcGFyYW1ldGVyJyB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCh1cmwsIHsgbWF4UmVkaXJlY3RzOiA1LCBoZWFkZXJzOiB7ICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wJyB9IH0pO1xuICAgIGNvbnN0IGh0bWwgPSByZXNwb25zZS5kYXRhIGFzIHN0cmluZztcbiAgICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWwpO1xuICAgIC8vIFJlbW92ZSBtZWdhLW1lbnUgY29udGVudCBnbG9iYWxseSBiZWZvcmUgZXh0cmFjdGlvblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZU1lZ2EgPSAvbWVnYVstXyBdP21lbnUvaTtcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gJCgnW2NsYXNzXScpLmZpbHRlcigoXywgZWwpID0+IHJlTWVnYS50ZXN0KCgkKGVsKS5hdHRyKCdjbGFzcycpIHx8ICcnKSkpLnRvQXJyYXkoKTtcbiAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpICQodG9SZW1vdmUpLnJlbW92ZSgpO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgY29uc3QgYmFzZSA9IG5ldyBVUkwodXJsKS50b1N0cmluZygpO1xuXG4gICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHBhcnNlUHJvZHVjdCh1cmwpO1xuICAgIGNvbnN0IHN0b3JlTmFtZSA9IGV4dHJhY3RTdG9yZU5hbWUoJCwgdXJsKTtcbiAgICBjb25zdCBsb2dvT2JqID0gZXh0cmFjdExvZ28oJCwgdXJsKTtcbiAgICBjb25zdCBoZXJvSW1hZ2VzID0gY29sbGVjdEltYWdlcygkLCBiYXNlLCAnaGVybycpO1xuICAgIC8vIFByZWZlciBtb2JpbGUtYmFubmVyIGltYWdlcyBvbiBjdXJyZW50IHBhZ2U7IHRoZW4gYWxzbyB0cnkgaG9tZXBhZ2UgYW5kIG1lcmdlL2RlZHVwZVxuICAgIGxldCBiYW5uZXJJbWFnZXMgPSBjb2xsZWN0TW9iaWxlQmFubmVySW1hZ2VzKCQsIGJhc2UpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSBuZXcgVVJMKGJhc2UpLm9yaWdpbjtcbiAgICAgIGNvbnN0IGhvbWVSZXMgPSBhd2FpdCBheGlvcy5nZXQob3JpZ2luLCB7IGhlYWRlcnM6IHsgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAnIH0sIG1heFJlZGlyZWN0czogNSB9KTtcbiAgICAgIGNvbnN0ICRob21lID0gY2hlZXJpby5sb2FkKGhvbWVSZXMuZGF0YSBhcyBzdHJpbmcpO1xuICAgICAgY29uc3QgaG9tZUJhbm5lcnMgPSBjb2xsZWN0TW9iaWxlQmFubmVySW1hZ2VzKCRob21lLCBvcmlnaW4gKyAnLycpO1xuICAgICAgYmFubmVySW1hZ2VzID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5iYW5uZXJJbWFnZXMsIC4uLmhvbWVCYW5uZXJzXSkpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIGlnbm9yZSBob21lcGFnZSBmZXRjaCBlcnJvcnNcbiAgICB9XG4gICAgaWYgKGJhbm5lckltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJhbm5lckltYWdlcyA9IGNvbGxlY3RJbWFnZXMoJCwgYmFzZSwgJ2Jhbm5lcicpO1xuICAgIH1cbiAgICBjb25zdCB7IGNhbmRpZGF0ZXM6IGNvbG9yQ2FuZGlkYXRlcywgcHJpbWFyeTogcHJpbWFyeUNvbG9yLCB0ZXh0OiB0ZXh0Q29sb3IgfSA9IGV4dHJhY3RQcmltYXJ5QW5kVGV4dCgkKTtcbiAgICAvLyBFeHRyYWN0IGFubm91bmNlbWVudCBjb3B5IHRleHQgaWYgcHJlc2VudFxuICAgIGxldCBhbm5vdW5jZW1lbnRDb3B5ID0gJyc7XG4gICAgY29uc3QgYW5uID0gJCgnW2NsYXNzKj1cImFubm91bmNlbWVudFwiIGldLCBbY2xhc3MqPVwiYW5vdW5jZW1lbnRcIiBpXScpLmZpcnN0KCk7XG4gICAgaWYgKGFubiAmJiBhbm4ubGVuZ3RoKSB7XG4gICAgICBhbm5vdW5jZW1lbnRDb3B5ID0gKGFubi50ZXh0KCkgfHwgJycpLnJlcGxhY2UoL1xccysvZywnICcpLnRyaW0oKTtcbiAgICB9XG4gICAgY29uc3QgZm9udEZhbWlsaWVzID0gZXh0cmFjdEZvbnRzKCQpO1xuXG4gICAgY29uc3QgcGF5bG9hZDogQW5hbHl6ZVJlc3BvbnNlID0ge1xuICAgICAgc3RvcmVOYW1lLFxuICAgICAgbG9nbzogbG9nb09iai51cmwsXG4gICAgICBsb2dvU3ZnOiBsb2dvT2JqLnN2ZyxcbiAgICAgIGhlcm9JbWFnZXMsXG4gICAgICBiYW5uZXJJbWFnZXMsXG4gICAgICBjb2xvclNjaGVtZTogcHJpbWFyeUNvbG9yID8gW3ByaW1hcnlDb2xvcl0gOiBbXSxcbiAgICAgIHByaW1hcnlDb2xvcixcbiAgICAgIHRleHRDb2xvcixcbiAgICAgIGNvbG9yQ2FuZGlkYXRlczogY29sb3JDYW5kaWRhdGVzLFxuICAgICAgZm9udEZhbWlsaWVzLFxuICAgICAgYW5ub3VuY2VtZW50Q29weSxcbiAgICAgIHByb2R1Y3RcbiAgICB9O1xuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHBheWxvYWQpO1xuICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5emUgZXJyb3InLCBlcnIubWVzc2FnZSB8fCBlcnIpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gYW5hbHl6ZSBwYWdlJyB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImF4aW9zIiwiY2hlZXJpbyIsInBhcnNlUHJvZHVjdCIsImFic29sdXRlVXJsIiwiYmFzZSIsInVybCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJvcmlnaW4iLCJ0b1N0cmluZyIsInJnYlRvSGV4IiwiaW5wdXQiLCJtIiwibWF0Y2giLCJyIiwiTWF0aCIsIm1heCIsIm1pbiIsInBhcnNlSW50IiwiZyIsImIiLCJ0b0hleCIsIm4iLCJwYWRTdGFydCIsInRvVXBwZXJDYXNlIiwibm9ybWFsaXplQ29sb3IiLCJ2YWwiLCJjbGVhbmVkIiwidHJpbSIsInJlcGxhY2UiLCJ0ZXN0IiwiaGV4IiwiYXNIZXgiLCJleHRyYWN0Q29sb3JDYW5kaWRhdGVzIiwiJCIsImJhc2VDc3NUZXh0cyIsImNhbmRpZGF0ZXMiLCJwdXNoIiwic291cmNlIiwiY29sb3IiLCJjIiwiZWFjaCIsIl8iLCJlbCIsInN0eWxlIiwiYXR0ciIsIm1CZyIsIm1Cb3JkZXIiLCJjc3MiLCJyZUFubiIsImV4ZWMiLCJyZUN0YUJnIiwicmVDdGFCb3JkZXIiLCJyZVV0aWwiLCJyZUJ1dHRvblRhZyIsInNlZW4iLCJTZXQiLCJmaWx0ZXIiLCJoYXMiLCJhZGQiLCJleHRyYWN0UHJpbWFyeUFuZFRleHQiLCJzdHlsZXMiLCJjb250ZW50cyIsInRleHQiLCJwcmltYXJ5IiwidGhlbWUiLCJ0aGVtZUhleCIsInByZWZlcnJlZCIsInN1YnN0cmluZyIsInlpcSIsInVuZGVmaW5lZCIsImV4dHJhY3RGb250cyIsInNldCIsImhyZWYiLCJmYW0iLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJzcGxpdCIsImZvckVhY2giLCJjaHVuayIsIm1hdGNoZXMiLCJibG9ja2VkIiwiQXJyYXkiLCJmcm9tIiwiZiIsInRvTG93ZXJDYXNlIiwic2xpY2UiLCJjb2xsZWN0SW1hZ2VzIiwidHlwZSIsInJlc3VsdHMiLCJyZWdleCIsIiRlbCIsImNscyIsInBhcmVudCIsImlkIiwic3JjIiwid0F0dHIiLCJva0J5QXR0ciIsImlzTmFOIiwib2tCeVNyYyIsImNvbGxlY3RNb2JpbGVCYW5uZXJJbWFnZXMiLCJleHRyYWN0U3RvcmVOYW1lIiwiYmFzZVVybCIsIm9nIiwidGl0bGUiLCJmaXJzdCIsImhvc3QiLCJob3N0bmFtZSIsImV4dHJhY3RMb2dvIiwibG9nb0NvbnRhaW5lcnMiLCJ0b0FycmF5Iiwic3ZnIiwiZmluZCIsImxlbmd0aCIsImh0bWwiLCJpbWciLCJjYW5kIiwiZmFsbGJhY2siLCJoZWFkZXJTZWxlY3RvcnMiLCIkaGVhZGVyIiwiam9pbiIsImFuY2hvcnMiLCJhIiwiJGEiLCJhYnNIcmVmIiwiaW1ncyIsImJlc3QiLCIkaW1nIiwidyIsImgiLCJhcmVhIiwicGVuYWx0eSIsInNjb3JlIiwiaGFuZGxlciIsInJlcSIsInJlcyIsInF1ZXJ5Iiwic3RhdHVzIiwianNvbiIsImVycm9yIiwicmVzcG9uc2UiLCJtYXhSZWRpcmVjdHMiLCJoZWFkZXJzIiwiZGF0YSIsImxvYWQiLCJyZU1lZ2EiLCJ0b1JlbW92ZSIsInJlbW92ZSIsInByb2R1Y3QiLCJzdG9yZU5hbWUiLCJsb2dvT2JqIiwiaGVyb0ltYWdlcyIsImJhbm5lckltYWdlcyIsImhvbWVSZXMiLCIkaG9tZSIsImhvbWVCYW5uZXJzIiwiY29sb3JDYW5kaWRhdGVzIiwicHJpbWFyeUNvbG9yIiwidGV4dENvbG9yIiwiYW5ub3VuY2VtZW50Q29weSIsImFubiIsImZvbnRGYW1pbGllcyIsInBheWxvYWQiLCJsb2dvIiwibG9nb1N2ZyIsImNvbG9yU2NoZW1lIiwiZXJyIiwiY29uc29sZSIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/analyze.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fanalyze.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();